#!/usr/bin/env bash

# This file is part of COùòïCEPT, the cosmological ùòï-body code in Python.
# Copyright ¬© 2015‚Äì2018 Jeppe Mosgaard Dakin.
#
# COùòïCEPT is free software: You can redistribute it and/or modifypath
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# COùòïCEPT is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with COùòïCEPT. If not, see http://www.gnu.org/licenses/
#
# The author of COùòïCEPT can be contacted at dakin(at)phys.au.dk
# The latest version of COùòïCEPT is available at
# https://github.com/jmd-dk/concept/



# This script downloads and installs the COùòïCEPT code with all its
# dependencies. If run without an argument, it will prompt for an
# installation directory. Alternatively, this directory can be passed as
# an argument. Everything will be installed within this directory.
# All tests can be skipped by supplying --fast as an argument.
# You can also download and run the newest version of this script by
# executing the following command:
# bash <(wget -O- https://raw.githubusercontent.com/jmd-dk/concept/master/installer)
#
# This script should be compatible with bash version 3.0 or later.
#
# Before installing the sofware into the specified directory,
# the installer will check for the following system dependencies:
# - awk
# - gcc
# - g++
# - gfortran
# - grep
# - gzip
# - make
# - sed
# - tar
# - wget
# - glibc
# - as and ld
# - Linux headers
# If any of these are missing, an attempt will be made to locate the
# system's package manager. If successful, you will be asked to install
# the missing system dependency, which will require root access.
# If you supply the -y argument when invoking this script, all missing
# system dependencies will be installed in this way without querying.
#
# The following software will be installed in order:
# - zlib     (needed by libpng, HDF5 and Python)
# - libpng   (needed by matplotlib)
# - GSL
# - MPICH/OpenMPI
# - HDF5
# - FFTW
# - FreeType (needed by matplotlib)
# - ncurses  (needed by _curses, which is needed by blessings)
# - Perl     (needed by OpenSSL)
# - OpenSSL  (needed by pip)
# - libffi   (needed by _ctypes, which is needed by pip)
# - OpenBLAS (needed by SciPy and also used by NumPy)
# - Python, with the following packages (together with their own Python
#   package dependencies):
#     - Blessings
#     - Cython
#     - CythonGSL
#     - Nose (needed by CLASS and NumPy)
#     - parameterized (needed by CLASS)
#     - pytest (needed by SciPy)
#     - NumPy
#     - SciPy
#     - Matplotlib
#     - MPI4Py
#     - H5Py
#     - pip & setuptools (if any of the above)
# - CLASS
# - COùòïCEPT
# - FFTW 2 (needed by GADGET)
# - GADGET
#
# By default, any pre-installed versions of the above software will be
# ignored. Should you wish COùòïCEPT to use one such pre-installed
# component, you have to declare its directory path through the
# "programname_dir" environment variable. E.g. to use a pre-installed
# gsl library:
# gsl_dir=/path/to/gsl /path/to/installer
# The set of such environment variables correspond to the program names
# above (though using lowercase only), except for MPI,
# which are just mpi_dir.
#
# You may specify which MPI implementation to use - either MPICH or
# OpenMPI - by setting the "mpi" environment variable to "mpich" or
# "openmpi", respectively. The default is MPICH.
#
# Should you choose to use a pre-installed Python distribution
# (by setting the python_dir variable), any missing Python packages
# will be installed in this distribution. Pre-installed Python packages
# will not be touched; e.g. if the installer wishes to install NumPy
# 1.10.4, but 1.10.3 is already installed, the packages will not be
# updated. If you want such Python package updates (or downgrades),
# set the "pythonpackagename_install" environment variable to "yes".
# E.g. to overwrite a pre-installed NumPy package:
# numpy_install=yes python_dir=/path/to/python /path/to/installer
#
# If you choose to use a pre-installed Python distribution, it is your
# responsibility that pip is installed as part of this distribution.
# Also, if the blessings package is not pre-installed in the Python
# distribution, Python should at least be compiled with the ncurses
# library.
#
# Should you wish to install a specific version of some dependency
# program, simply set the environment variable "programname_version"
# when invoking the installer. This also works for Python packages.



# If invoked directly from the web (e.g. via wget), a small pause
# ensures that the print outs will not corrupt the loading bar.
sleep 2
# Newer versions of wget saves a copy of the printout when using the
# -O- option to a file called wget-log[.x], x ‚àà ‚Ñï. Remove any such log
# produced from invoking this script via wget.
wget_log_maxage=300
for filename in *; do
    if [ ! -f "${filename}" ] || [[ "${filename}" != "wget-log"* ]]; then
        continue
    fi
    fileage=$(($(date +%s) - $(stat -c '%Y' "${filename}")))
    if [ ${fileage} -lt ${wget_log_maxage} ]; then
        rm -f "${filename}"
    fi
done



##################
# Specifications #
##################
# The MPI implementation to use
mpi_lower="$(echo "${mpi}" | tr '[:upper:]' '[:lower:]')"
if [ -z "${mpi}" ]; then
    # If mpi_dir is specified,
    # try to determine whether OpenMPI or MPICH is used.
    if [ -n "${mpi_dir}" ]; then
        if [ -f "${mpi_dir}/bin/ompi_info" ]; then
            mpi="openmpi"
        elif [ -f "${mpi_dir}/bin/mpichversion" ]; then
            mpi="mpich"
        else
            mpi="unknown"
        fi
    else
        # Use MPICH by default
        mpi="mpich"
    fi
elif [ "${mpi_lower}" != "openmpi" ] && [ "${mpi_lower}" != "mpich" ]; then
    echo "Specified MPI implementation mpi=\"${mpi}\" not recognized.
Will use MPICH" >&2
    mpi="mpich"
fi
mpi="$(echo "${mpi}" | tr '[:upper:]' '[:lower:]')"
# This function sets the variables "name_dir" (if not set already)
# and "name_preinstalled".
set_dir(){
    # Arguments: Program name, install directory.
    # Set "name_preinstalled" if "name_dir" is already set
    eval "${1}_preinstalled=yes"
    eval "[ -n \"\${${1}_dir}\" ] || ${1}_preinstalled=no"
    # Set "name_dir" if "name_dir" is not already set
    # or "name" should be installed.
    eval "[ -n \"\${${1}_dir}\" ] || ${1}_dir=\"${2}\""
    eval "(! (   [ \"\${${1}_install}\"      == \"no\" ] \
              && [ \"\${${1}_preinstalled}\" == \"no\" ])) || ${1}_dir=\"\""
}
# The install_explicit_only environment variable, when set to "yes",
# disables all implicit installations.
if [ "${install_explicit_only}" == "yes" ]; then
    for progname in "concept"         \
                    "class"           \
                    "fftw"            \
                    "fftw_for_gadget" \
                    "freetype"        \
                    "gadget"          \
                    "gsl"             \
                    "hdf5"            \
                    "libffi"          \
                    "libpng"          \
                    "mpi"             \
                    "ncurses"         \
                    "openblas"        \
                    "openssl"         \
                    "perl"            \
                    "python"          \
                    "zlib"            \
                    "blessings"       \
                    "cython"          \
                    "cythongsl"       \
                    "h5py"            \
                    "matplotlib"      \
                    "mpi4py"          \
                    "nose"            \
                    "numpy"           \
                    "parameterized"   \
                    "pytest"          \
                    "scipy"; do
        eval "[ -n \"\${${progname}_install}\" ] || ${progname}_install=\"no\""
    done
fi
# Specification of paths. The substring "__top_dir__"
# will later be replaced with the top level directory.
set_dir "class"           "__top_dir__/class"
set_dir "concept"         "__top_dir__/concept"
set_dir "fftw"            "__top_dir__/fftw"
set_dir "freetype"        "__top_dir__/freetype"
set_dir "gadget"          "__top_dir__/gadget"
set_dir "fftw_for_gadget" "${gadget_dir}/fftw"
set_dir "gsl"             "__top_dir__/gsl"
set_dir "hdf5"            "__top_dir__/hdf5"
set_dir "libpng"          "__top_dir__/libpng"
set_dir "mpi"             "__top_dir__/${mpi}"
set_dir "openblas"        "__top_dir__/openblas"
set_dir "perl"            "__top_dir__/perl"
set_dir "python"          "__top_dir__/python"
set_dir "ncurses"         "${python_dir}"
set_dir "openssl"         "${python_dir}"
set_dir "libffi"          "${python_dir}"
set_dir "zlib"            "__top_dir__/zlib"
log="__top_dir__/install_log"
env_file="__top_dir__/.env"
paths_file="__top_dir__/.paths"

# This function sets the variable "name_version" if not set already.
# For preinstalled software, set "name_version" to "pre-installed".
# If a third argument is given, this is the version to fall back to,
# in case of unsuccessful retrievel of the link to the first version.
set_version(){
    # Arguments: Program name, version, [fallback version]
    eval "[ -z \"\${${1}_version}\" ] || ${1}_version_specifiedbyuser=\"true\""
    eval "[ -n \"\${${1}_version}\" ] || ${1}_version=\"${2}\""
    eval "[ \"\${${1}_preinstalled}\" != \"yes\" ] || ${1}_version=\"pre-installed\""
    if [ -n "${3}" ]; then
        eval "${1}_version_fallback=\"${3}\""
    fi
}
# Specification of software versions.
# The rightmost column are fallbacks, which will be used if the
# link to the version given by the middle column is broken.
# In case of COùòïCEPT and CLASS, possible versions are the corresponding
# GitHub branches and releases.
set_version "concept"         "master"
set_version "class"           "2.6.3"
set_version "fftw"            "3.3.8"  "3.3.8"
set_version "fftw_for_gadget" "2.1.5"  "2.1.5"   # Do not change
set_version "freetype"        "2.9.1"  "2.9.1"
set_version "gadget"          "2.0.7"            # Do not change
set_version "gsl"             "2.5"    "2.5"
set_version "hdf5"            "1.10.2" "1.10.2"
set_version "libffi"          "3.2.1"  "3.2.1"
set_version "libpng"          "1.6.35" "1.6.33"
if [ "${mpi}" == "mpich" ]; then
    set_version "mpi"         "3.2.1"  "3.2.1"
elif [ "${mpi}" == "openmpi" ]; then
    set_version "mpi"         "3.1.1"
fi
set_version "ncurses"         "6.1"    "6.1"
set_version "openblas"        "0.2.20" "0.2.20"
set_version "openssl"         "1.1.0h" "1.1.0h"
set_version "perl"            "5.28.0"
set_version "python"          "3.7.0"
set_version "zlib"            "1.2.11" "1.2.11"
# Python packages
set_version "blessings"     "1.7"
set_version "cython"        "0.28.4"
set_version "cythongsl"     "0.2.2"
set_version "h5py"          "2.8.0"
set_version "matplotlib"    "2.2.2"
set_version "mpi4py"        "3.0.0"
set_version "nose"          "1.3.7"
set_version "numpy"         "1.15.0"
set_version "parameterized" "0.6.1"
set_version "pip"           "18.0"
set_version "pytest"        "3.6.4"
set_version "scipy"         "1.1.0"
set_version "setuptools"    "40.0.0"
# Note that the versions may be changed further down due to known
# compatibility issues between specific versions of the above programs
# and specific versions of system dependencies.



#################
# Initial setup #
#################
# Set up error trapping
ctrl_c(){
    current_step="aborting"
    sleep 0.5
    kill -- -$$ > /dev/null 2>&1 || :
    exit 2
}
abort(){
    sleep 0.5
    kill -- -$$ > /dev/null 2>&1 || :
    exit 1
}
trap 'ctrl_c' SIGINT
trap 'abort' EXIT
set -e

# For the terminal to be able to print Unicode characters correctly,
# the terminal character set needs to be compatible. To ensure this,
# we set all locale settings to en_US.UTF-8.
export LC_ALL="en_US.UTF-8"
export LANG="en_US.UTF-8"
# Set the terminal if unset or broken
if [ -z "${TERM}" ] || [ "${TERM}" == "dumb" ]; then
    export TERM="linux"
fi

# ANSI/VT100 escape sequences
esc="\x1b"
# Text formatting
esc_normal="${esc}[0m"
esc_bold="${esc}[1m"
esc_italic="${esc}[3m"
esc_reverted="${esc}[7m"
esc_no_italic="${esc}[23m"
# The name of the program, nicely typesat
if [ -z "${esc_concept}" ]; then
    esc_concept="CO${esc_italic}N${esc_no_italic}CEPT"
else
    esc_concept="${esc_concept//\$\{esc_italic\}/${esc_italic}}"
    esc_concept="${esc_concept//\$\{esc_no_italic\}/${esc_no_italic}}"
fi
esc_concept_double_backslashes="${esc_concept//\\/\\\\}"

# Text colors
esc_red="${esc}[91m"
esc_green="${esc}[92m"
esc_yellow="${esc}[93m"
# Cursor movement
esc_up="${esc}[1A"
esc_erase="${esc}[K"
# Special characters
en_quad="\xE2\x80\x80"
# Functions for pretty printing text
heading(){
    printf "\n${esc_bold}${esc_yellow}${1}${esc_normal}\n"
}
error(){
    printf "\n${esc_bold}${esc_red}${1}${esc_normal}\n" >&2
}

# Print out welcome message
if [ "${say_welcome}" != "no" ]; then
    heading "${esc_bold}${esc_yellow}This is the installation script for ${esc_concept},
the cosmological ${esc_italic}N${esc_no_italic}-body code in Python${esc_normal}"
fi

# Status control sequenses
status="initialization"
status_prefix="__new_status__="
status_prefix_length=${#status_prefix}
status_disable="disable"
status_enable="enable"
status_on="on"
status_off="off"
status_visible="${status_on}"
status_finish="finish_successfully"

# Backup of initial environment variables
env_var_names=(BLAS             \
               CC               \
               CFLAGS           \
               CPPFLAGS         \
               CXX              \
               F9X              \
               FC               \
               FFLAGS           \
               HDF5_DIR         \
               HDF5_MPI         \
               LAPACK           \
               LD_LIBRARY_PATH  \
               LDFLAGS          \
               LIBS             \
               MPICC            \
               MPILIBS          \
               PATH             \
               PERL             \
               PKG_CONFIG_PATH  \
               PNG_CFLAGS       \
               PNG_LIBS         \
               RUNTESTS_VERBOSE \
               TMPDIR           \
               ZLIB_CFLAGS      \
               ZLIB_LIBS        \
               ZLIBLIB          \
               ZLIBINC          \
               )
for env_var_name in "${env_var_names[@]}"; do
    # Save initial state (set/unset) of the environment variable
    if [ -n "$(eval "echo "\${${env_var_name}+x}"")" ]; then
        eval "${env_var_name}_set=\"True\""
    else
        eval "${env_var_name}_set=\"False\""
    fi
    # Save initial value of the environment variable
    eval "${env_var_name}_backup=\"\${${env_var_name}}\""
done
# Function that resets all above environment
# variables to their initial state.
reset_environment(){
    for env_var_name in "${env_var_names[@]}"; do
        eval "env_var_set=\"\${${env_var_name}_set}\""
        if [ "${env_var_set}" == "True" ]; then
            # env_var_name initially set
            eval "export ${env_var_name}=\"\${${env_var_name}_backup}\""
        else
            # env_var_name initially unset
            unset "${env_var_name}"
        fi
    done
}

# Set test_success variables
class_test_success="yes"
concept_test_success="yes"
fftw_test_success="yes"
fftw_for_gadget_test_success="yes"
freetype_test_success="yes"
gadget_test_success="yes"
gsl_test_success="yes"
hdf5_test_success="yes"
libffi_test_success="yes"
libpng_test_success="yes"
mpi_test_success="yes"
ncurses_test_success="yes"
openblas_test_success="yes"
openssl_test_success="yes"
perl_test_success="yes"
python_test_success="yes"
zlib_test_success="yes"
numpy_test_success="yes"
scipy_test_success="yes"

# Read in command line arguments
if [ -z "${fast_install}" ]; then
    fast_install="no"
fi
if [ -z "${auto_install}" ]; then
    auto_install="no"
fi
if [ -z "${top_dir_specified}" ]; then
    top_dir_specified="no"
fi
for var in "$@"; do
    if [ "${var}" == "--fast" ]; then
        fast_install="yes"
    elif [ "${var}" == "-y" ]; then
        auto_install="yes"
    elif [ "${top_dir_specified}" == "no" ]; then
        top_dir="${var}"
        top_dir_specified="yes"
    else
        if [ "${var}" != "${top_dir}" ]; then
            error "Got command line argument \"${var}\", "\
"but the installation path is already set to \"${top_dir}\""
            exit 1
        fi
    fi
done
# Set sleep_time, the amount of seconds spend sleeping at various stages
sleep_time=10
if [ "${fast_install}" == "yes" ]; then
    sleep_time=0
fi
# If auto install mode has been requested using the -y option,
# prompt for root password if not already root.
if [ "${auto_install}" == "yes" ] && [ ${EUID} -ne 0 ]; then
    echo "Auto install mode has been requested with the '-y' option, but you are not root."
    sudo -k
    while :; do
        read -s -p "[sudo] password for $(whoami): " sudo_password
        echo
        output="$(echo "${sudo_password}" | sudo -S echo hello 2>&1 || :)"
        output="${output##* }"
        if [ "${output}" == "hello" ]; then
            break
        fi
        echo "Sorry, try again."
    done
    sudo_command="echo \"${sudo_password}\" | sudo -S"
    sudo_password=""
else
    sudo_command="sudo"
fi

# Creating top level directory (top_dir)
current_step="setup of top level directory"
if [ "${top_dir_specified}" == "no" ]; then
    printf "\nWhere should the ${esc_concept} code be installed?"
    read -p "$(echo $'\n> ')" -e top_dir
    if [ -z "${top_dir}" ]; then
        # The user hit enter without writing a path.
        # Install in current directory.
        top_dir="."
    fi
fi
initial_dir="$(pwd)"  # It is crucial that this line is before any cd
convert_to_abs_path(){
    # Arguments: path
    current_dir="$(pwd)"
    cd "${initial_dir}"
    # Places backslashes before spaces.
    # These are needed when expanding tilde, but they will not persist.
    abs_path="${1//[ ]/\\ }"
    # Expand tilde
    eval abs_path="${abs_path}"
    # Convert to absolute path
    abs_path=$(readlink -m "${abs_path}")
    cd "${current_dir}"
    echo "${abs_path}"
}
top_dir="$(convert_to_abs_path "${top_dir}")"
printf "\nThe code will be installed in \"${top_dir}\"\n"
mkdir -p "${top_dir}"
cd "${top_dir}"

# Function which prints the absolute path of a given command.
# If the command is not an executable file on the PATH but instead a
# known function, the input command is printed as is. If the command
# cannot be found at all, nothing is printed and an exit code of 1
# is returned.
get_command(){
    command_name="${1}"
    # Use the type builtin to locate the command
    path="$(type "${command_name}" 2>/dev/null || :)"
    path="${path##* }"
    if [[ "${path}" == "/"* ]]; then
        # The command is a path
        path="$(readlink -f "${path}")"
        echo "${path}"
        return 0
    elif [ -n "${path}" ]; then
        # The command exists as a function
        echo "${command_name}"
        return 0
    fi
    # The command does not exist
    return 1
}

# Check whether system dependencies are installed and located on PATH
current_step="check for preinstalled system dependencies"
# Check for package manager and set package names
set_package_names(){
    # Arguments: Package name for awk, gcc, g++, gfortran, grep, gzip,
    # make, sed, tar, wget, glibc, as and ld, Linux headers.
    i=0
    for package in      \
        "awk"           \
        "gcc"           \
        "gxx"           \
        "gfortran"      \
        "grep"          \
        "gzip"          \
        "make"          \
        "sed"           \
        "tar"           \
        "wget"          \
        "glibc"         \
        "as_ld"         \
        "linux_headers" \
    ; do
        ((i += 1))
        eval "${package}_package=\${${i}}"
    done
}
set_package_manager_and_names(){
    # This function takes no arguments
    package_manager=""
    for pmanager in \
        "apt"       \
        "apt-get"   \
        "aptitude"  \
        "dnf"       \
        "yum"       \
        "zypper"    \
        "urpmi"     \
        "pacman"    \
        "eopkg"     \
        "emerge"    \
        "slackpkg"  \
    ; do
        if get_command "${pmanager}" >/dev/null; then
            # Package manager found
            package_manager="${pmanager}"
            # Package names
            case "${package_manager}" in
                "apt") install_command="${sudo_command} ${package_manager} install -y"
                    set_package_names               \
                        "gawk"                      \
                        "gcc"                       \
                        "g++"                       \
                        "gfortran"                  \
                        "grep"                      \
                        "gzip"                      \
                        "make"                      \
                        "sed"                       \
                        "tar"                       \
                        "wget"                      \
                        "libc6 libc6-dev"           \
                        "binutils"                  \
                        "linux-headers-$(uname -r)"
                    break
                    ;;
                "apt-get") install_command="${sudo_command} ${package_manager} -y install"
                    set_package_names               \
                        "gawk"                      \
                        "gcc"                       \
                        "g++"                       \
                        "gfortran"                  \
                        "grep"                      \
                        "gzip"                      \
                        "make"                      \
                        "sed"                       \
                        "tar"                       \
                        "wget"                      \
                        "libc6 libc6-dev"           \
                        "binutils"                  \
                        "linux-headers-$(uname -r)"
                    break
                    ;;
                "aptitude") install_command="${sudo_command} ${package_manager} -y install"
                    set_package_names               \
                        "gawk"                      \
                        "gcc"                       \
                        "g++"                       \
                        "gfortran"                  \
                        "grep"                      \
                        "gzip"                      \
                        "make"                      \
                        "sed"                       \
                        "tar"                       \
                        "wget"                      \
                        "libc6 libc6-dev"           \
                        "binutils"                  \
                        "linux-headers-$(uname -r)"
                    break
                    ;;
                "dnf") install_command="${sudo_command} ${package_manager} -y install"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc-c++"           \
                        "gcc-gfortran"      \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc glibc-devel" \
                        "binutils"          \
                        "kernel-headers"
                    break
                    ;;
                "yum") install_command="${sudo_command} ${package_manager} -y install"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc-c++"           \
                        "gcc-gfortran"      \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc glibc-devel" \
                        "binutils"          \
                        "kernel-headers"
                    break
                    ;;
                "zypper") install_command="${sudo_command} ${package_manager} -n install"
                    set_package_names          \
                        "gawk"                 \
                        "gcc"                  \
                        "gcc-c++"              \
                        "gcc-fortran"          \
                        "grep"                 \
                        "gzip"                 \
                        "make"                 \
                        "sed"                  \
                        "tar"                  \
                        "wget"                 \
                        "glibc glibc-devel"    \
                        "binutils"             \
                        "linux-kernel-headers"
                    break
                    ;;
                "urpmi") install_command="${sudo_command} ${package_manager} --auto"
                    set_package_names              \
                        "gawk"                     \
                        "gcc"                      \
                        "gcc-c++"                  \
                        "gcc-gfortran"             \
                        "grep"                     \
                        "gzip"                     \
                        "make"                     \
                        "sed"                      \
                        "tar"                      \
                        "wget"                     \
                        "glibc glibc-devel"        \
                        "binutils"                 \
                        "kernel-userspace-headers"
                    break
                    ;;
                "pacman") install_command="${sudo_command} ${package_manager} -S --noconfirm"
                    set_package_names   \
                        "gawk"          \
                        "gcc"           \
                        "gcc"           \
                        "gcc-fortran"   \
                        "grep"          \
                        "gzip"          \
                        "make"          \
                        "sed"           \
                        "tar"           \
                        "wget"          \
                        "glibc"         \
                        "binutils"      \
                        "linux-headers"
                    break
                    ;;
                "eopkg") install_command="${sudo_command} ${package_manager} install -y"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "g++"               \
                        "gfortran"          \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc glibc-devel" \
                        "binutils"          \
                        "linux-headers"
                    break
                    ;;
                "emerge") install_command="${sudo_command} ${package_manager}"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc"               \
                        "fortran"           \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc"             \
                        "binutils"          \
                        "linux-headers"
                    break
                    ;;
                "slackpkg") install_command="${sudo_command} ${package_manager} install"
                    set_package_names       \
                        "gawk"              \
                        "gcc"               \
                        "gcc-g++"           \
                        "gcc-gfortran"      \
                        "grep"              \
                        "gzip"              \
                        "make"              \
                        "sed"               \
                        "tar"               \
                        "wget"              \
                        "glibc"             \
                        "binutils"          \
                        "kernel-headers"
                    break
                    ;;
            esac
            break
        fi
    done
}
set_package_manager_and_names
# Function for testing whether system dependencies are installed and
# located on PATH. For missing system dependencies, it will attempt to
# figure out the command to install it.
check_system_dependency(){
    # Arguments: Command, package name
    if ! get_command "${1}" >/dev/null; then
        # Package not installed
        if [ -n "${package_manager}" ]; then
            # Package manager found
            echo
            if [ "${auto_install}" == "yes" ]; then
                echo "Auto installing '${1}'"
                eval "${install_command} ${2}"
                printf "${1} successfully installed\n\n"
            else
                echo "Could not find '${1}'"
                echo "You can install it by typing:"
                echo "${install_command} ${2}"
                while :; do
                    read -p "Run above command now? [Y/n] " yn
                    case "${yn}" in
                        [Yy]* ) eval "${install_command} ${2}"
                                printf "${1} successfully installed\n\n"
                                return
                                ;;
                        [Nn]* ) error "Terminated install due to missing component '${1}'"
                                exit 1
                                ;;
                        ""    ) eval "${install_command} ${2}"
                                printf "${1} successfully installed\n\n"
                                return
                                ;;
                        *     ) error "Terminated install due to missing component '${1}'"
                                exit 1
                                ;;
                    esac
                done
                exit 1
            fi
        else
            # No package manager found
            error "Error: Could not find '${1}'"
            exit 1
        fi
    fi
}
check_system_dependency "awk"      "${awk_package}"
check_system_dependency "gcc"      "${gcc_package}"
check_system_dependency "g++"      "${gxx_package}"
check_system_dependency "gfortran" "${gfortran_package}"
check_system_dependency "grep"     "${grep_package}"
check_system_dependency "gzip"     "${gzip_package}"
check_system_dependency "make"     "${make_package}"
check_system_dependency "sed"      "${sed_package}"
check_system_dependency "tar"      "${tar_package}"
check_system_dependency "wget"     "${wget_package}"

# Though gcc is now guaranteed to be installed,
# it may miss important components, which we check for here.
current_step="check of gcc components"
gcc_test(){
    # Arguments:
    #   - Name of gcc component
    #   - C source code to test
    #   - Expected output
    #   - Text to write if fail
    #   - Name of package to install if fail
    name="$1"
    C_source="$2"
    expected_output="$3"
    message="$4"
    package_name="$5"
    # Prepare for gcc test
    current_dir="$(pwd)"
    gcc_test_dir="${top_dir}/tmp/gcc_test"
    rm -rf "${gcc_test_dir}"
    mkdir -p "${gcc_test_dir}"
    cd "${gcc_test_dir}"
    # Write C source to file
    echo "${C_source}" > main.c
    # Test compile and run
    for i in 0 1; do
        gcc_test_success="yes"
        gcc main.c -o main || gcc_test_success="no"
        if [ "${gcc_test_success}" == "yes" ]; then
            gcc_test_output="$(./main)"
            if [ "${gcc_test_output}" != "${expected_output}" ]; then
                gcc_test_success="no"
            fi
        fi
        if [ "${gcc_test_success}" == "no" ]; then
            if [ $i -eq 0 ]; then
                # Test failed.
                # Prompt for installation of needed package.
                echo
                echo "${message}"
                if [ -z "${package_manager}" ]; then
                    # No package manager found
                    error "Error: Could not find any installed package manager"
                    exit 1
                fi
                if [ "${auto_install}" == "yes" ]; then
                    echo "Auto installing ${name}"
                    eval "${install_command} ${package_name}"
                else
                    echo "To ensure that ${name} are installed, type:"
                    echo "${install_command} ${package_name}"
                    gcc_test_prompt(){
                        while :; do
                            read -p "Run above command now? [Y/n] " yn
                            case "${yn}" in
                                [Yy]* ) eval "${install_command} ${package_name}"
                                        return
                                        ;;
                                [Nn]* ) error "Terminated install due to missing component: ${name}"
                                        exit 1
                                        ;;
                                ""    ) eval "${install_command} ${package_name}"
                                        return
                                        ;;
                                *     ) error "Terminated install due to missing component: ${name}"
                                        exit 1
                                        ;;
                            esac
                        done
                        exit 1
                    }
                    gcc_test_prompt
                fi
                printf "${name} successfully installed\n\n"
            else
                # Test failed even after installing the needed package
                error "Terminated install due to gcc failing to \
properly compile \"${gcc_test_dir}/main.c\""
                exit 1
            fi
        fi
    done
    # Cleanup after test
    cd "${current_dir}"
    rm -rf "${gcc_test_dir}"
}
# Basic gcc test, checking for the standard library,
# the assembler and linker.
gcc_test                                                \
    "the gcc C standard library, assembler and linker"  \
    '
#include <stdio.h>
int main(void){
    printf("hello\n");
    return 0;
}
'                                                       \
    "hello"                                             \
    "gcc could not compile even a simple C program. \
We need to make sure that the gcc C standard library, \
as well as the assembler and linker are all installed." \
    "${glibc_package} ${as_ld_package}"
# Check for the Linux headers
gcc_test                                                \
    "the Linux headers"  \
    '
#include <linux/limits.h>
#include <stdio.h>
int main(void){
    printf("hello\n");
    return 0;
}
'                                                       \
    "hello"                                             \
    "gcc could not find the Linux headers. \
We need to make sure that these are installed."         \
    "${linux_headers_package}"

# Change default versions if they are known not to work
# with the present versions of the system dependencies.
:

# Replace "__top_dir__" in paths with the user specified top_dir.
# Also convert to absolute path and check that this path exist for
# pre-installed libraries.
fix_path(){
    # Arguments: Program name
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    # Replace "__top_dir__"
    eval "[ \"\${${progname=}_preinstalled}\" == \"yes\" ] \
          || ${progname=}_dir=\"\${${progname=}_dir/__top_dir__/${top_dir}}\""
    # Convert to absolute path
    eval "${progname=}_dir=\"\$(convert_to_abs_path \"\${${progname=}_dir}\")\""
    # Check that the path to pre-installed dependencies exist
    if eval "[ \"\${${progname}_preinstalled}\" == \"yes\" ] \
             && [ ! -d \"\${${progname}_dir}\" ] \
             && [ ! -f \"\${${progname}_dir}\" ]"; then
        error "The specified directory\n\"$(eval "echo \${${progname}_dir}")\"\n\
for ${1/CONCEPT/$esc_concept} does not exist!"
        exit 1
    fi
    # Check and correct user specified dependency directories
    eval "progname_dir=\"\${${progname=}_dir}\""
    if [ -f "${progname_dir}" ]; then
        progname_dir="$(dirname ${progname_dir})"
    fi
    if [ "${progname}" == 'class' ] && [ "${class_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/class" ]; then
            if [ -f "${progname_dir}/../class" ]; then
                class_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate CLASS at \"${class_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'concept' ] && [ "${concept_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/concept" ]; then
            if [ -f "${progname_dir}/../concept" ]; then
                concept_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate COùòïCEPT at \"${concept_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'fftw' ] && [ "${fftw_preinstalled}" == "yes" ]; then
        if     [ ! -f "${progname_dir}/lib/libfftw3.so" ] \
            && [ ! -f "${progname_dir}/lib/libfftw3f.so" ]; then
            if     [ -f "${progname_dir}/../lib/libfftw3.so" ] \
                || [ -f "${progname_dir}/../lib/libfftw3f.so" ]; then
                fftw_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate FFTW at \"${fftw_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'freetype' ] && [ "${freetype_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/lib/libfreetype.so" ]; then
            if [ -f "${progname_dir}/../lib/libfreetype.so" ]; then
                freetype_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate FreeType at \"${freetype_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'gadget' ] && [ "${gadget_preinstalled}" == "yes" ]; then
        if [ ! -d "${progname_dir}/Gadget2" ]; then
            if [ -d "${progname_dir}/../Gadget2" ]; then
                gadget_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate Gadget at \"${gadget_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'gsl' ] && [ "${gsl_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/lib/libgsl.so" ]; then
            if [ -f "${progname_dir}/../lib/libgsl.so" ]; then
                gsl_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate GSL at \"${gsl_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'hdf5' ] && [ "${hdf5_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/lib/libhdf5.so" ]; then
            if [ -f "${progname_dir}/../lib/libhdf5.so" ]; then
                hdf5_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate HDF5 at \"${hdf5_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'libffi' ] && [ "${libffi_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/lib/libffi.so" ]; then
            if [ -f "${progname_dir}/../lib/libffi.so" ]; then
                libffi_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate libffi at \"${libffi_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'libpng' ] && [ "${libpng_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/lib/libpng.so" ]; then
            if [ -f "${progname_dir}/../lib/libpng.so" ]; then
                libpng_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate libpng at \"${libpng_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'mpi' ] && [ "${mpi_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/bin/mpiexec" ]; then
            if [ -f "${progname_dir}/../bin/mpiexec" ]; then
                mpi_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate MPI at \"${mpi_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'ncurses' ] && [ "${ncurses_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/lib/libncurses.so" ]; then
            if [ -f "${progname_dir}/../lib/libncurses.so" ]; then
                ncurses_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate ncurses at \"${ncurses_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'openblas' ] && [ "${openblas_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/include/cblas.h" ]; then
            if [ -f "${progname_dir}/../include/cblas.h" ]; then
                openblas_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate OpenBLAS at \"${openblas_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'openssl' ] && [ "${openssl_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/lib/libssl.so" ]; then
            if [ -f "${progname_dir}/../lib/libssl.so" ]; then
                openssl_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate OpenSSL at \"${openblas_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'perl' ] && [ "${perl_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/bin/perl" ]; then
            if [ -f "${progname_dir}/../bin/perl" ]; then
                perl_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate Perl at \"${perl_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'python' ] && [ "${python_preinstalled}" == "yes" ]; then
        if     [ ! -f "${progname_dir}/bin/python" ] \
            && [ ! -f "${progname_dir}/bin/python3" ]; then
            if     [ -f "${progname_dir}/../bin/python" ] \
                || [ -f "${progname_dir}/../bin/python3" ]; then
                python_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate Python at \"${python_dir}\""
                exit 1
            fi
        fi
    fi
    if [ "${progname}" == 'zlib' ] && [ "${zlib_preinstalled}" == "yes" ]; then
        if [ ! -f "${progname_dir}/lib/libz.so" ]; then
            if [ -f "${progname_dir}/../lib/libz.so" ]; then
                zlib_dir="$(dirname ${progname_dir})"
            else
                error "Could not locate zlib at \"${zlib_dir}\""
                exit 1
            fi
        fi
    fi
}
fix_path "CLASS"
fix_path "CONCEPT"
fix_path "FreeType"
fix_path "zlib"
fix_path "libpng"
fix_path "ncurses"
fix_path "OpenBLAS"
fix_path "OpenSSL"
fix_path "libffi"
fix_path "Perl"
fix_path "Python"
fix_path "FFTW"
fix_path "GADGET"
fix_path "FFTW for GADGET"
fix_path "GSL"
fix_path "HDF5"
fix_path "MPI"
log="${log/__top_dir__/${top_dir}}"
env_file="${env_file/__top_dir__/${top_dir}}"
paths_file="${paths_file/__top_dir__/${top_dir}}"

# Check whether this script is run locally or remotely via ssh
ssh="True"
if [ -z "${SSH_CLIENT}" ] && [ -z "${SSH_TTY}" ]; then
    ssh="False"
fi

# Set the "make_jobs" variable, holding the -j option for future
# make commands, enabling parallel compilations when running locally.
# Also set OMP_NUM_THREADS to 1 when running remotely,
# so that OpenMP runs serially.
make_jobs="-j"
if [ "${ssh}" == "True" ]; then
    make_jobs=""
    export OMP_NUM_THREADS=1
fi



##########################
# Dependency discovering #
##########################
current_step="discovery of dependencies"
# Flags specifying whether or not any Python packages,
# software (meaning anything but Python packages) or any of those
# should be installed.
install_any_pypackages="no"
install_any_software="no"
install_anything="no"
assume_preinstalled(){
    # Arguments: Program name (lowercase)
    eval "name_preinstalled=\"\${${1}_preinstalled}\""
    if [ "${name_preinstalled}" == "no" ]; then
        eval "${1}_preinstalled=\"yes\""
        eval "${1}_dir=\"\""
        eval "${1}_version=\"pre-installed\""
    fi
}
# If Python is pre-installed, assume that OpenSSL,
# libffi and ncurses are also pre-installed.
if [ "${python_preinstalled}" == "yes" ]; then
    assume_preinstalled "openssl"
    assume_preinstalled "libffi"
    assume_preinstalled "ncurses"
fi
# If OpenSSL is pre-installed, assume that Perl is also pre-installed
if [ "${openssl_preinstalled}" == "yes" ]; then
    assume_preinstalled "perl"
fi

# Set "pypackage"_preinstalled variables
blessings_preinstalled="no"
cython_preinstalled="no"
cythongsl_preinstalled="no"
h5py_preinstalled="no"
matplotlib_preinstalled="no"
mpi4py_preinstalled="no"
nose_preinstalled="no"
numpy_preinstalled="no"
parameterized_preinstalled="no"
pytest_preinstalled="no"
scipy_preinstalled="no"
pip_preinstalled="no"
if [ "${python_preinstalled}" == "yes" ]; then
    python=$(ls -1 "${python_dir}/bin/python"* | head -n 1)
    for pypackage in blessings     \
                     cython        \
                     cythongsl     \
                     h5py          \
                     matplotlib    \
                     mpi4py        \
                     nose          \
                     numpy         \
                     parameterized \
                     pytest        \
                     scipy         \
                     pip; do
        pypackage_preinstalled=$("${python}" -c "
try:
    import ${pypackage}
    print('yes')
except:
    print('no')
" 2>/dev/null
        )
        eval "${pypackage}_preinstalled=\"${pypackage_preinstalled}\""
    done
fi

# Variables telling whether or not a program needs to be installed.
# COùòïCEPT (install by default)
if [ -z "${concept_install}" ]; then
    concept_install="no"
    if [ "${concept_preinstalled}" == "no" ]; then
        concept_install="yes"
    fi
fi
# CLASS (needed by COùòïCEPT)
if [ -z "${class_install}" ]; then
    class_install="no"
    if [ "${class_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        class_install="yes"
    fi
fi
# GADGET (needed by COùòïCEPT)
if [ -z "${gadget_install}" ]; then
    gadget_install="no"
    if [ "${gadget_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        gadget_install="yes"
    fi
fi
# FFTW for GADGET (needed by GADGET)
if [ -z "${fftw_for_gadget_install}" ]; then
    fftw_for_gadget_install="no"
    if [ "${fftw_for_gadget_preinstalled}" == "no" ] && [ "${gadget_install}" == "yes" ]; then
        fftw_for_gadget_install="yes"
    fi
fi
# Python (needed by COùòïCEPT and CLASS)
if [ -z "${python_install}" ]; then
    python_install="no"
    if [ "${python_preinstalled}" == "no" ] && (   [ "${concept_install}" == "yes" ] \
                                                || [ "${class_install}"   == "yes" ]); then
        python_install="yes"
    fi
fi
# Python packages (needed by CLASS and COùòïCEPT)
if [ -z "${pip_install}" ]; then
    # Always install pip if Python is to be installed
    pip_install="no"
    if [ "${python_install}" == "yes" ]; then
        pip_install="yes"
    fi
fi
for pypackage in blessings     \
                 cython        \
                 cythongsl     \
                 h5py          \
                 matplotlib    \
                 mpi4py        \
                 nose          \
                 numpy         \
                 parameterized \
                 pytest        \
                 scipy; do
    eval "pypackage_install=\"\${${pypackage}_install}\""
    if [ -z "${pypackage_install}" ]; then
        eval "${pypackage}_install=\"no\""
        eval "pypackage_preinstalled=\"\${${pypackage}_preinstalled}\""
        if [ "${pypackage_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
            eval "${pypackage}_install=\"yes\""
        fi
    fi
    eval "pypackage_install=\"\${${pypackage}_install}\""
done
# FFTW (needed by COùòïCEPT)
if [ -z "${fftw_install}" ]; then
    fftw_install="no"
    if [ "${fftw_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        fftw_install="yes"
    fi
fi
# HDF5 (needed by COùòïCEPT)
if [ -z "${hdf5_install}" ]; then
    hdf5_install="no"
    if [ "${hdf5_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        hdf5_install="yes"
    fi
fi
# MPI (needed by COùòïCEPT)
if [ -z "${mpi_install}" ]; then
    mpi_install="no"
    if [ "${mpi_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        mpi_install="yes"
    fi
fi
# GSL (needed by COùòïCEPT)
if [ -z "${gsl_install}" ]; then
    gsl_install="no"
    if [ "${gsl_preinstalled}" == "no" ] && [ "${concept_install}" == "yes" ]; then
        gsl_install="yes"
    fi
fi
# libpng (needed by matplotlib)
if [ -z "${libpng_install}" ]; then
    libpng_install="no"
    if [ "${libpng_preinstalled}" == "no" ] && [ "${matplotlib_install}" == "yes" ]; then
        libpng_install="yes"
    fi
fi
# zlib (needed by HDF5, libpng and Python)
if [ -z "${zlib_install}" ]; then
    zlib_install="no"
    if [ "${zlib_preinstalled}" == "no" ] && (   [ "${hdf5_install}"   == "yes" ] \
                                              || [ "${libpng_install}" == "yes" ] \
                                              || [ "${python_install}" == "yes" ]); then
        zlib_install="yes"
    fi
fi
# FreeType (needed by matplotlib)
if [ -z "${freetype_install}" ]; then
    freetype_install="no"
    if [ "${freetype_preinstalled}" == "no" ] && [ "${matplotlib_install}" == "yes" ]; then
        freetype_install="yes"
    fi
fi
# ncurses (needed by Python, if Python is needed by COùòïCEPT)
if [ -z "${ncurses_install}" ]; then
    ncurses_install="no"
    if [ "${ncurses_preinstalled}" == "no" ] && [ "${python_install}"  == "yes" ] \
                                             && [ "${concept_install}" == "yes" ]; then
        ncurses_install="yes"
    fi
fi
# OpenBLAS (needed by NumPy and SciPy)
if [ -z "${openblas_install}" ]; then
    openblas_install="no"
    if [ "${openblas_preinstalled}" == "no" ] && (   [ "${numpy_install}" == "yes" ] \
                                                  || [ "${scipy_install}" == "yes" ]); then
        openblas_install="yes"
    fi
fi
# OpenSSL (needed by pip)
if [ -z "${openssl_install}" ]; then
    openssl_install="no"
    if [ "${openssl_preinstalled}" == "no" ] && [ "${pip_install}" == "yes" ]; then
        openssl_install="yes"
    fi
fi
# libffi (needed by pip)
if [ -z "${libffi_install}" ]; then
    libffi_install="no"
    if [ "${libffi_preinstalled}" == "no" ] && [ "${pip_install}" == "yes" ]; then
        libffi_install="yes"
    fi
fi
# Perl (needed by OpenSSL)
if [ -z "${perl_install}" ]; then
    perl_install="no"
    if [ "${perl_preinstalled}" == "no" ] && [ "${openssl_install}" == "yes" ]; then
        perl_install="yes"
    fi
fi
# The install_any_software, install_any_pypackages
# and install_anything variables.
if     [ "${concept_install}"         == "yes" ] \
    || [ "${class_install}"           == "yes" ] \
    || [ "${gadget_install}"          == "yes" ] \
    || [ "${fftw_for_gadget_install}" == "yes" ] \
    || [ "${python_install}"          == "yes" ] \
    || [ "${fftw_install}"            == "yes" ] \
    || [ "${hdf5_install}"            == "yes" ] \
    || [ "${mpi_install}"             == "yes" ] \
    || [ "${gsl_install}"             == "yes" ] \
    || [ "${libpng_install}"          == "yes" ] \
    || [ "${zlib_install}"            == "yes" ] \
    || [ "${freetype_install}"        == "yes" ] \
    || [ "${ncurses_install}"         == "yes" ] \
    || [ "${openblas_install}"        == "yes" ] \
    || [ "${openssl_install}"         == "yes" ] \
    || [ "${libffi_install}"          == "yes" ] \
    || [ "${perl_install}"            == "yes" ]; then
        install_any_software="yes"
fi
if     [ "${blessings_install}"       == "yes" ] \
    || [ "${cython_install}"          == "yes" ] \
    || [ "${cythongsl_install}"       == "yes" ] \
    || [ "${h5py_install}"            == "yes" ] \
    || [ "${matplotlib_install}"      == "yes" ] \
    || [ "${mpi4py_install}"          == "yes" ] \
    || [ "${nose_install}"            == "yes" ] \
    || [ "${numpy_install}"           == "yes" ] \
    || [ "${parameterized_install}"   == "yes" ] \
    || [ "${pytest_install}"          == "yes" ] \
    || [ "${scipy_install}"           == "yes" ]; then
        install_any_pypackages="yes"
fi
if [ "${install_any_software}" == "yes" ] || [ "${install_any_pypackages}" == "yes" ]; then
    install_anything="yes"
fi



#######################################################
# Prompt for configuration of password-less ssh login #
#######################################################
# If running remotely via ssh, the installation might be on a cluster,
# which could consist of several nodes. Running MPI jobs via MPICH
# on multiple nodes require password-less ssh login to the nodes
# to be sat up.
# If MPICH is to be installed and we are running remotely via ssh,
# prompt the user for automatic setup of password-less ssh login.
setup_passwordless_ssh="False"
if [ "${ssh}" == "True" ] && [ "${mpi}" == "mpich" ] && [ "${mpi_install}" == "yes" ]; then
    # The setup of the password-less ssh login will move any preexisting
    # ~/.ssh directory to ~/.ssh_before_CONCEPT.
    passwordless_ssh_note=""
    if [ -d ~/".ssh" ]; then
        passwordless_ssh_note=" (the existing ~/.ssh\n\
directory will be moved to ~/.ssh_before_CONCEPT)"
    fi
    # Prompt the user
    printf "\n
If this is a cluster of multiple nodes, password-less ssh login to these
nodes needs to be configured in order for MPICH (and hence ${esc_concept})
to run multi-node MPI jobs.

Should password-less ssh login to the nodes be configured${passwordless_ssh_note}?"
    read -p " [Y/n] " yn
    case "${yn}" in
        [Yy]* ) setup_passwordless_ssh="True"
                ;;
        [Nn]* ) setup_passwordless_ssh="False"
                ;;
        ""    ) setup_passwordless_ssh="True"
                ;;
        *     ) setup_passwordless_ssh="False"
                ;;
    esac
fi



###########################
# Beginning of subprocess #
(
# Set up error trapping
ctrl_c_subprocess(){
    trap : 0
    ctrl_c
    exit 0
}
abort_subprocess(){
    trap : 0
    if [ "${current_step}" != "aborting" ]; then
        error "An error occurred during ${current_step}!"
    fi
    abort
    exit 0
}
trap 'ctrl_c_subprocess' SIGINT
trap 'abort_subprocess' EXIT
set -e

# Functions for controlling the current status
set_status(){
    echo "${status_prefix}${1}"
}
disable_status(){
    echo "${status_prefix}${status_disable}"
}
enable_status(){
    echo "${status_prefix}${status_enable}"
}
successfully_finish_status(){
    echo "${status_prefix}${status_finish_successfully}"
}
# These are needed to get the spcacing right in the output
current_step="beginning subprocess"
set_status "Beginning subprocess"



##################################################
# Apply configuration of password-less ssh login #
##################################################
# Do the configuration if specified by the user
if [ "${setup_passwordless_ssh}" == "True" ]; then
    current_step="configuration of password-less ssh login between nodes"
    set_status "Configuring password-less ssh login between nodes"
    # The type of encryption to use for the ssh keys.
    # Should be "dsa" or "rsa".
    key_type="rsa"
    # Move existing ~/.ssh directory
    if [ -d ~/".ssh" ]; then
        rm -rf ~/".ssh_before_CONCEPT"
        mv ~/".ssh" ~/".ssh_before_CONCEPT"
    fi
    # Generate a public/private key pair
    mkdir -p ~/".ssh"
    ssh-keygen -t "${key_type}" -N "" -f ~/".ssh/id_${key_type}" >/dev/null
    # Add public key to the list of keys allowed to log in
    cat ~/".ssh/id_${key_type}.pub" >> ~/".ssh/authorized_keys"
    cat ~/".ssh/id_${key_type}.pub" >> ~/".ssh/authorized_keys2"
    # Suppress future confirmation dialogs
    echo "Host *
  StrictHostKeyChecking no
  UserKnownHostsFile /dev/null
  LogLevel ERROR
" >> ~/".ssh/config"
    chmod go-rwx ~/".ssh/config"
    # Remove any previously known hosts
    # (there should be none as ~/.ssh is newly created).
    rm -f "known_hosts"*
    # Only the user may have write permissions to her home directory,
    # in order for ssh to allow password-less login.
    chmod go-w ~
    # Ensure that only the user has any acces to the private key
    chmod go-rwx ~/".ssh/id_${key_type}"
    # Inform the user on this change
    printf "\nPassword-less ssh login to nodes has been configured\n"
fi



#############################
# URL's to all the software #
#############################
# In this section, ${progame_url} are defined for each program.
# In order for the rest of this script to work, these URLs must point
# to archives containing a single top-level directory.

# Function for checking that a given url actually exists
validate_url(){
    # Arguments: Program name, [exit on error ("true" or "false")]
    progname="$(echo "${1}" | tr '[:upper:]' '[:lower:]')"
    progname="${progname// /_}"
    exit_on_error="true"
    if [ -n "$2" ]; then
        exit_on_error="$2"
    fi
    if [ "${progname}" == "mpi" ]; then
        if [ "${mpi}" == "mpich" ]; then
            current_step="validation of MPICH link"
            set_status "Validating MPICH link"
        elif [ "${mpi}" == "openmpi" ]; then
            current_step="validation of OpenMPI link"
            set_status "Validating OpenMPI link"
        fi
    else
        current_step="validation of ${1/CONCEPT/$esc_concept} link"
        set_status "Validating ${1/CONCEPT/$esc_concept_double_backslashes} link"
    fi
    url="$(eval "echo \"\${${progname}_url}\"")"
    filename="$(basename "${url}")"
    for n in {1..3}; do
        for ipv in "--inet4-only" "--inet6-only" ""; do
            wget_status="success"
            if [[ "${url}" == "ftp://"* ]]; then
                # wget do not always return with a non-zero status on
                # failure when using ftp.
                mkdir -p "${top_dir}/tmp"
                (cd "${top_dir}/tmp"
                 wget -t 1 --timeout 30 --no-check-certificate --no-dns-cache -q --spider \
                      --no-remove-listing ${ipv} "${url}" || :)
                grep "${filename}" "${top_dir}/tmp/.listing" > /dev/null 2>&1 \
                     || wget_status="error"
                rm -f "${top_dir}/tmp/.listing"
            else
                wget -t 1 --timeout 30 --no-check-certificate --no-dns-cache -q --spider ${ipv} \
                     "${url}" || wget_status="error"
            fi
            if [ "${wget_status}" == "success" ]; then
                break
            fi
        done
        if [ "${wget_status}" == "success" ]; then
            break
        fi
        sleep 1
    done
    validate_url_status="${wget_status}"
    if [ "${exit_on_error}" == "true" ]; then
        if [ "${wget_status}" != "success" ]; then
            error "Error: The ${1} link is broken: ${url}"
            exit 1
        fi
    fi
}

# Function for letting versions fall back to their secondary,
# fallback values, in case of unsuccessful retrievel of primary version.
fallback(){
    # Arguments: Program name
    progname="$(echo "${1}" | tr '[:upper:]' '[:lower:]')"
    progname="${progname// /_}"
    eval "progname_version=\"\${${progname}_version}\""
    eval "progname_version_fallback=\"\${${progname}_version_fallback}\""
    if [ "${progname}" == "mpi" ]; then
        if [ "${mpi}" == "mpich" ]; then
            realname="MPICH"
        elif [ "${mpi}" == "openmpi" ]; then
            realname="OpenMPI"
        fi
    else
        realname="${1}"
    fi
    if [ "${progname_version}" != "${progname_version_fallback}" ]; then
        echo "Falling back to ${realname} version ${progname_version_fallback}"
    fi
    progname_version="${progname_version_fallback}"
    eval "${progname}_version=\"\${progname_version}\""
    eval "${progname}_version_fallback=\"\${progname_version_fallback}\""
}

# Function which checks the download and installation progress
# of all the programs based on helper files created by previous
# invocations of this script. The function is called with the program
# name (progname) as the argument and it will set the variables
# progname_downloaded and progname_installed to either "yes" or "no".
check_progress(){
    # Arguments: Program name
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    # The program installation directory
    eval "progdir=\"\${${progname}_dir}\""
    # COùòïCEPT itself will not have a .installation_finished file in its
    # directory. Instead it uses the .installation_finished in the
    # GADGET directory.
    if [ "${progname}" == "concept" ]; then
        progdir="${gadget_dir}"
    fi
    # The program version
    eval "progversion=\"\${${progname}_version}\""
    # If the program has already been fully installed, a file called
    # .installation_finished will be placed in the program installation
    # directory. Note that some programs share a common installation
    # directory and thefore also a common .installation_finished file.
    eval "${progname}_installed=\"no\""
    if [ -f "${progdir}/.installation_finished" ]; then
        while read line; do
            prog_prev="$(echo "${line}" | grep '^Program:*'      \
                                        | sed 's/^Program:\s//g' \
                                        | sed 's/^ *//')"
            if [ -n "${prog_prev}" ]; then
                prog_prev_real="${prog_prev// /_}"
                prog_prev_real="$(echo "${prog_prev_real}" | tr '[:upper:]' '[:lower:]')"
            fi
            version_prev="$(echo "${line}" | grep '^Version:*'      \
                                           | sed 's/^Version:\s//g' \
                                           | sed 's/^ *//')"
            if    [ "${version_prev}" == "${progversion}" ] \
               && [ "${prog_prev_real}" == "${progname}" ]; then
                eval "${progname}_installed=\"yes\""
                # Installed programs should always count as downloaded
                eval "${progname}_downloaded=\"yes\""
                return
            fi
        done <"${progdir}/.installation_finished"
    fi
    # If the program is not yet installed fully, remove its directory,
    # cleaning up after any previous failed installation attempts.
    if [ "${progname}" == "gadget" ]; then
        # FFTW for GADGET is placed inside the GADGET directory
        if [ -d "${gadget_dir}/fftw" ]; then
            mv "${gadget_dir}/fftw" "${gadget_dir}/.fftw"
        fi
        rm -rf "${gadget_dir}/"*
        if [ -d "${gadget_dir}/.fftw" ]; then
            mv "${gadget_dir}/.fftw" "${gadget_dir}/fftw"
        fi
        if [ -d "${gadget_dir}" ] && [ ! "$(ls -A "${gadget_dir}")" ]; then
            rm -rf "${gadget_dir}"
        fi
    elif [ "${progname}" == "python" ]; then
        # Files from ncurses, OpenSSL and libffi are placed all around
        # in ${python_dir}, so we cannot just delete this directory.
        :
    elif [ "${progname}" == "ncurses" ]; then
        rm -rf "${python_dir}/include/ncurses"
    elif [ "${progname}" == "openssl" ]; then
        rm -rf "${python_dir}/include/openssl"
    elif [ "${progname}" == "libffi" ]; then
        rm -rf "${python_dir}/lib/libffi"*
    elif [ "${progname}" == "concept" ]; then
        # In the case of COùòïCEPT, ${progdir} is set to
        # the GADGET directory.
        rm -rf "${concept_dir}"
    else
        # The files of all other programs live isolated
        # in their very own dedicated directory.
        rm -rf "${progdir}"
    fi
    # The url to the installation file for this program
    eval "url=\"\${${progname}_url}\""
    # The directory for the downloaded file
    download_dir="${top_dir}/tmp/${progname}"
    # If the source file has already been downloaded fully, a file
    # called .download_finished will be placed in the download_dir with
    # information about this file.
    eval "${progname}_downloaded=\"no\""
    if [ -f "${download_dir}/.download_finished" ]; then
        file_prev="$(grep "^File:*" "${download_dir}/.download_finished" | sed 's/^File:\s//g' \
                                                                         | sed 's/^ *//')"
        url_prev="$( grep "^URL:*"  "${download_dir}/.download_finished" | sed 's/^URL:\s//g' \
                                                                         | sed 's/^ *//')"
        if [ -f "${download_dir}/${file_prev}" ] && [ "${url_prev}" == "${url}" ]; then
            eval "${progname}_downloaded=\"yes\""
        fi
    fi
}

# COùòïCEPT
if [ "${concept_install}" == "yes" ]; then
    # Either download the current state of the master branch
    # or a specific release.
    if [ "${concept_version}" == "master" ]; then
        concept_url="https://github.com/jmd-dk/concept/archive/${concept_version}.tar.gz"
    else
        concept_version="${concept_version/v/}"
        concept_url="https://github.com/jmd-dk/concept/archive/v${concept_version}.tar.gz"
    fi
    # Check if already downloaded/installed
    check_progress "CONCEPT"
    # If not yet downloaded, validate the URL
    if [ "${concept_downloaded}" != "yes" ]; then
        validate_url "CONCEPT" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary COùòïCEPT link broken: ${concept_url}"
            error "Error: The installer does not know of a secondary COùòïCEPT link"
            exit 1
        fi
    fi
fi

# CLASS
if [ "${class_install}" == "yes" ]; then
    # Either download specific release or specific branch
    current_step="processing of CLASS link"
    dots="${class_version//[^.]}"
    ndots="${#dots}"
    if [ "${ndots}" == 1 ]; then
        class_url="https://github.com/lesgourg/class_public/archive/${class_version}.tar.gz"
    elif [ "${ndots}" == 2 ]; then
        class_version=${class_version/v/}
        class_url="https://github.com/lesgourg/class_public/archive/v${class_version}.tar.gz"
    else
        error "No CLASS URL known for version ${class_version}"
        exit 1
    fi
    # Check if already installed/downloaded
    check_progress "CLASS"
    # If not yet downloaded, validate the URL
    if [ "${class_downloaded}" != "yes" ]; then
        validate_url "CLASS" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary CLASS link broken: ${class_url}"
            error "Error: The installer does not know of a secondary CLASS link"
            exit 1
        fi
    fi
fi

# FFTW
if [ "${fftw_install}" == "yes" ]; then
    fftw_url="http://www.fftw.org/fftw-${fftw_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FFTW"
    # If not yet downloaded, validate the URL
    if [ "${fftw_downloaded}" != "yes" ]; then
        validate_url "FFTW" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FFTW link broken: ${fftw_url}"
            fallback "FFTW"
            fftw_url="ftp://ftp.fftw.org/pub/fftw/fftw-${fftw_version}.tar.gz"
            echo "Using secondary FFTW link: ${fftw_url}"
            # Check if already installed and/or downloaded
            check_progress "FFTW"
            # If not yet downloaded, validate the URL
            if [ "${fftw_downloaded}" != "yes" ]; then
                validate_url "FFTW"
            fi
        fi
    fi
fi

# FFTW for GADGET
if [ "${fftw_for_gadget_install}" == "yes" ]; then
    fftw_for_gadget_url="http://www.fftw.org/fftw-${fftw_for_gadget_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FFTW for GADGET"
    # If not yet downloaded, validate the URL
    if [ "${fftw_for_gadget_downloaded}" != "yes" ]; then
        validate_url "FFTW for GADGET" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FFTW 2 link broken: ${fftw_for_gadget_url}"
            fallback "FFTW for GADGET"
            fftw_for_gadget_url="ftp://ftp.fftw.org/pub/fftw/\
fftw-${fftw_for_gadget_version}.tar.gz"
            echo "Using secondary FFTW 2 link: ${fftw_for_gadget_url}"
            # Check if already installed and/or downloaded
            check_progress "FFTW for GADGET"
            # If not yet downloaded, validate the URL
            if [ "${fftw_for_gadget_downloaded}" != "yes" ]; then
                validate_url "FFTW for GADGET"
            fi
        fi
    fi
fi

# FreeType
if [ "${freetype_install}" == "yes" ]; then
    freetype_url="http://download.savannah.gnu.org/releases/freetype/\
freetype-${freetype_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "FreeType"
    # If not yet downloaded, validate the URL
    if [ "${freetype_downloaded}" != "yes" ]; then
        validate_url "FreeType" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary FreeType link broken: ${freetype_url}"
            fallback "freetype"
            freetype_url="http://sourceforge.net/projects/freetype/files/freetype2/\
${freetype_version}/freetype-${freetype_version}.tar.gz"
            echo "Using secondary FreeType link: ${freetype_url}"
            # Check if already installed and/or downloaded
            check_progress "FreeType"
            # If not yet downloaded, validate the URL
            if [ "${freetype_downloaded}" != "yes" ]; then
                validate_url "FreeType"
            fi
        fi
    fi
fi

# GADGET
if [ "${gadget_install}" == "yes" ]; then
    gadget_url="http://www.mpa-garching.mpg.de/gadget/gadget-${gadget_version}.tar.gz"
    # Check if already installed/downloaded
    check_progress "GADGET"
    # If not yet downloaded, validate the URL
    if [ "${gadget_downloaded}" != "yes" ]; then
        validate_url "GADGET" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary GADGET link broken: ${gadget_url}"
            error "Error: The installer does not know of a secondary GADGET link"
            exit 1
        fi
    fi
fi

# GSL
if [ "${gsl_install}" == "yes" ]; then
    gsl_url="ftp://ftp.gnu.org/gnu/gsl/gsl-${gsl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "GSL"
    # If not yet downloaded, validate the URL
    if [ "${gsl_downloaded}" != "yes" ]; then
        validate_url "GSL" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary GSL link broken: ${gsl_url}"
            fallback "GSL"
            gsl_url="http://ftpmirror.gnu.org/gsl/gsl-${gsl_version}.tar.gz"
            echo "Using secondary gsl link: ${gsl_url}"
            # Check if already installed and/or downloaded
            check_progress "GSL"
            # If not yet downloaded, validate the URL
            if [ "${gsl_downloaded}" != "yes" ]; then
                validate_url "GSL"
            fi
        fi
    fi
fi

# HDF5
if [ "${hdf5_install}" == "yes" ]; then
    hdf5_version_major="$(echo "${hdf5_version}" | grep -o '[0-9]\.[0-9]*')"
    hdf5_url="https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-${hdf5_version_major}/\
hdf5-${hdf5_version}/src/hdf5-${hdf5_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "HDF5"
    # If not yet downloaded, validate the URL
    if [ "${hdf5_downloaded}" != "yes" ]; then
        validate_url "HDF5" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary HDF5 link broken: ${hdf5_url}"
            fallback "HDF5"
            hdf5_version_major="$(echo "${hdf5_version}" | grep -o '[0-9]\.[0-9]*')"
            hdf5_url="https://support.hdfgroup.org/ftp/HDF5/releases/hdf5-${hdf5_version_major}/\
hdf5-${hdf5_version}/src/hdf5-${hdf5_version}.tar.gz"
            echo "Using secondary HDF5 link: ${hdf5_url}"
            # Check if already installed and/or downloaded
            check_progress "HDF5"
            # If not yet downloaded, validate the URL
            if [ "${hdf5_downloaded}" != "yes" ]; then
                validate_url "HDF5"
            fi
        fi
    fi
fi

# libpng
if [ "${libpng_install}" == "yes" ]; then
    # For e.g. libpng_version 1.6.18, libpng_version_majors is 16
    libpng_url="http://prdownloads.sourceforge.net/libpng/libpng-${libpng_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "libpng"
    # If not yet downloaded, validate the URL
    if [ "${libpng_downloaded}" != "yes" ]; then
        validate_url "libpng" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary libpng link broken: ${libpng_url}"
            fallback "libpng"
            libpng_version_majors="$(echo "${libpng_version}" | grep -m 1 -o -P "[0-9]*\.[0-9]*" \
                                                              | head -n 1)"
            libpng_version_majors="$(echo "${libpng_version_majors//./}")"
            libpng_url="http://sourceforge.net/projects/libpng/files/\
libpng${libpng_version_majors}/older-releases/${libpng_version}/libpng-${libpng_version}.tar.gz"
            echo "Using secondary libpng link: ${libpng_url}"
            # Check if already installed and/or downloaded
            check_progress "libpng"
            # If not yet downloaded, validate the URL
            if [ "${libpng_downloaded}" != "yes" ]; then
                validate_url "libpng"
            fi
        fi
    fi
fi

# MPI
if [ "${mpi_install}" == "yes" ]; then
    if [ "${mpi}" == "mpich" ]; then
        # MPICH
        mpi_url="http://www.mpich.org/static/downloads/${mpi_version}/mpich-${mpi_version}.tar.gz"
        # Check if already installed and/or downloaded
        check_progress "MPI"
        # If not yet downloaded, validate the URL
        if [ "${mpi_downloaded}" != "yes" ]; then
            validate_url "MPI" "false"
            if [ "${validate_url_status}" != "success" ]; then
                echo "Primary MPICH link broken: ${mpi_url}"
                fallback "MPI"
                mpi_url="http://fossies.org/linux/misc/mpich-${mpi_version}.tar.gz"
                echo "Using secondary MPICH link: ${mpi_url}"
                # Check if already installed and/or downloaded
                check_progress "MPI"
                # If not yet downloaded, validate the URL
                if [ "${mpi_downloaded}" != "yes" ]; then
                    validate_url "MPI"
                fi
            fi
        fi
    elif [ "${mpi}" == "openmpi" ]; then
        # OpenMPI
        mpi_version_major="$(echo "${mpi_version}" | grep -m 1 -o -P "[0-9]*" \
                                                   | head -n 1)"
        mpi_version_major_dot_minor="$(echo "${mpi_version}" | grep -m 1 -o -P \
                                            "${mpi_version_major}\.[0-9]*")"
        mpi_url="https://www.open-mpi.org/software/ompi/v${mpi_version_major_dot_minor}/\
downloads/openmpi-${mpi_version}.tar.gz"
        # Check if already installed and/or downloaded
        check_progress "MPI"
        # If not yet downloaded, validate the URL
        if [ "${mpi_downloaded}" != "yes" ]; then
            validate_url "MPI" "false"
            if [ "${validate_url_status}" != "success" ]; then
                echo "Primary OpenMPI link broken: ${mpi_url}"
                error "Error: The installer does not know of a secondary OpenMPI link"
                exit 1
            fi
        fi
    fi
fi

# ncurses
if [ "${ncurses_install}" == "yes" ]; then
    ncurses_url="http://ftp.gnu.org/gnu/ncurses/ncurses-${ncurses_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "ncurses"
    # If not yet downloaded, validate the URL
    if [ "${ncurses_downloaded}" != "yes" ]; then
        validate_url "ncurses" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary ncurses link broken: ${ncurses_url}"
            fallback "ncurses"
            ncurses_url="http://ftpmirror.gnu.org/ncurses/ncurses-${ncurses_version}.tar.gz"
            echo "Using secondary ncurses link: ${ncurses_url}"
            # Check if already installed and/or downloaded
            check_progress "ncurses"
            # If not yet downloaded, validate the URL
            if [ "${ncurses_downloaded}" != "yes" ]; then
                validate_url "ncurses"
            fi
        fi
    fi
fi

# OpenBLAS
if [ "${openblas_install}" == "yes" ]; then
    openblas_url="https://github.com/xianyi/OpenBLAS/archive/v${openblas_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "OpenBLAS"
    # If not yet downloaded, validate the URL
    if [ "${openblas_downloaded}" != "yes" ]; then
        validate_url "OpenBLAS" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary OpenBLAS link broken: ${openblas_url}"
            fallback "openblas"
            openblas_url="https://sourceforge.net/projects/openblas/files/v${openblas_version}/\
OpenBLAS%20${openblas_version}%20version.tar.gz"
            echo "Using secondary OpenBLAS link: ${openblas_url}"
            # Check if already installed and/or downloaded
            check_progress "OpenBLAS"
            # If not yet downloaded, validate the URL
            if [ "${openblas_downloaded}" != "yes" ]; then
                validate_url "OpenBLAS"
            fi
        fi
    fi
fi

# OpenSSL
if [ "${openssl_install}" == "yes" ]; then
    openssl_url="https://www.openssl.org/source/openssl-${openssl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "OpenSSL"
    # If not yet downloaded, validate the URL
    if [ "${openssl_downloaded}" != "yes" ]; then
        validate_url "OpenSSL" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary OpenSSL link broken: ${openssl_url}"
            fallback "openssl"
            openssl_version_underscores="$(echo "${openssl_version}" | tr '.' '_')"
            openssl_url=https://github.com/openssl/openssl/archive/\
OpenSSL_${openssl_version_underscores}.tar.gz
            echo "Using secondary OpenSSL link: ${openssl_url}"
            # Check if already installed and/or downloaded
            check_progress "OpenSSL"
            # If not yet downloaded, validate the URL
            if [ "${openssl_downloaded}" != "yes" ]; then
                validate_url "OpenSSL"
            fi
        fi
    fi
fi

# libffi
if [ "${libffi_install}" == "yes" ]; then
    libffi_url="ftp://sourceware.org/pub/libffi/libffi-${libffi_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "libffi"
    # If not yet downloaded, validate the URL
    if [ "${libffi_downloaded}" != "yes" ]; then
        validate_url "libffi" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary libffi link broken: ${libffi_url}"
            fallback "libffi"
            libffi_url="https://sourceware.org/ftp/libffi/libffi-${libffi_version}.tar.gz"
            echo "Using secondary libffi link: ${libffi_url}"
            # Check if already installed and/or downloaded
            check_progress "libffi"
            # If not yet downloaded, validate the URL
            if [ "${libffi_downloaded}" != "yes" ]; then
                validate_url "libffi"
            fi
        fi
    fi
fi

# Perl
if [ "${perl_install}" == "yes" ]; then
    perl_url="http://www.cpan.org/src/5.0/perl-${perl_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "Perl"
    # If not yet downloaded, validate the URL
    if [ "${perl_downloaded}" != "yes" ]; then
        validate_url "Perl" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary Perl link broken: ${perl_url}"
            error "Error: The installer does not know of a secondary Perl link"
            exit 1
        fi
    fi
fi

# Python
if [ "${python_install}" == "yes" ]; then
    python_url="https://www.python.org/ftp/python/${python_version}/Python-${python_version}.tgz"
    # Check if already installed and/or downloaded
    check_progress "Python"
    # If not yet downloaded, validate the URL
    if [ "${python_downloaded}" != "yes" ]; then
        validate_url "Python" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary Python link broken: ${python_url}"
            error "Error: The installer does not know of a secondary Python link"
            exit 1
        fi
    fi
fi

# zlib
if [ "${zlib_install}" == "yes" ]; then
    zlib_url="http://sourceforge.net/projects/libpng/files/zlib/${zlib_version}/\
zlib-${zlib_version}.tar.gz"
    # Check if already installed and/or downloaded
    check_progress "zlib"
    # If not yet downloaded, validate the URL
    if [ "${zlib_downloaded}" != "yes" ]; then
        validate_url "zlib" "false"
        if [ "${validate_url_status}" != "success" ]; then
            echo "Primary zlib link broken: ${zlib_url}"
            fallback "zlib"
            zlib_url="http://zlib.net/zlib-${zlib_version}.tar.gz"
            echo "Using secondary zlib link: ${zlib_url}"
            # Check if already installed and/or downloaded
            check_progress "zlib"
            # If not yet downloaded, validate the URL
            if [ "${zlib_downloaded}" != "yes" ]; then
                validate_url "zlib"
            fi
        fi
    fi
fi

# Set "pypackage"_installed variables
blessings_installed="no"
cython_installed="no"
cythongsl_installed="no"
h5py_installed="no"
matplotlib_installed="no"
mpi4py_installed="no"
nose_installed="no"
numpy_installed="no"
parameterized_installed="no"
pytest_installed="no"
scipy_installed="no"
pip_installed="no"
if [ -n "${python_dir}" ]; then
    for python_version_major in 3 2; do
        if [ -f "${python_dir}/bin/python${python_version_major}" ]; then
            python_version_major_dot_minor=$("${python_dir}/bin/python${python_version_major}" -c \
                                 "from sys import version_info as v; \
                                 print(str(v.major) + '.' + str(v.minor))")
            python="${python_dir}/bin/python${python_version_major_dot_minor}"
            break
        fi
    done
fi
if [ -n "${python}" ] && [ "${python_installed}" == "yes" ]; then
    for pypackage in blessings     \
                     cython        \
                     cythongsl     \
                     h5py          \
                     matplotlib    \
                     mpi4py        \
                     nose          \
                     numpy         \
                     parameterized \
                     pytest        \
                     scipy         \
                     pip; do
        pypackage_installed=$("${python}" -c "
try:
    # CythonGSL has an extra underscore when importing
    if '${pypackage}' == 'cythongsl':
        import cython_gsl
    else:
        import ${pypackage}
    print('yes')
except:
    print('no')
" 2>/dev/null
        )
        eval "${pypackage}_installed=\"${pypackage_installed}\""
    done
fi

# Functions for printing out nice tables (these are superior to the
# "column" command on older systems, as this does not handle
# formatted output very well).
modify_element(){
    # Arguments: Character to be replaced, character to replace with
    for ((i = 0; i < nelements; i += 1)); do
        element="${table_to_print[i]}"
        table_to_print[i]="${element//$1/$2}"
    done
}
print_table(){
    # Arguments: Array to be printed (passed as array[@]),
    #            number of columns.
    table_to_print=("${!1}")
    nelements=${#table_to_print[@]}
    nc=${2}
    # Replace spaces with tildes
    modify_element " " "~"
    # Backup of table
    table_with_esc=("${table_to_print[@]}")
    # Remove escape sequences in table
    esc_normal_double_backslashes=$(echo "${esc_normal}" | sed 's,\\,\\\\,g')
    esc_bold_double_backslashes=$(echo "${esc_bold}" | sed 's,\\,\\\\,g')
    esc_italic_double_backslashes=$(echo "${esc_italic}" | sed 's,\\,\\\\,g')
    esc_no_italic_double_backslashes=$(echo "${esc_no_italic}" | sed 's,\\,\\\\,g')
    modify_element "${esc_normal_double_backslashes}" ""
    modify_element "${esc_bold_double_backslashes}" ""
    modify_element "${esc_italic_double_backslashes}" ""
    modify_element "${esc_no_italic_double_backslashes}" ""
    # Determine largest length of each column
    maxlengths=($(for i in $(eval "echo {1..${nc}}"); do echo 0; done))
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        length=${#table_to_print[i]}
        [ ${length} -gt ${maxlengths[c]} ] && maxlengths[c]=${length}
        ((c += 1))
        [ ${c} == ${nc} ] && c=0
    done
    # Count number of missing right spaces for each element
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        element="${table_to_print[i]}"
        nspaces[i]=$((${maxlengths[${c}]} - ${#element}))
        ((c += 1))
        [ ${c} == ${nc} ] && c=0
    done
    # Reinsert spaces
    table_to_print=("${table_with_esc[@]}")
    modify_element "~" "\ "
    # Print the table
    c=0
    for ((i = 0; i < nelements; i += 1)); do
        printf "${table_to_print[i]}"  # Print element
        [ ${nspaces[i]} -gt 0 ] && printf ' %.0s' $(eval "echo {1..${nspaces[i]}}")  # Print spaces
        ((c += 1))
        [ ${c} == ${nc} ] ||        printf "  "  # Print extra spaces
        [ ${c} == ${nc} ] && c=0 && printf "\n"  # Print newline
    done
}

# Write out installation overview.
# This overview take the form of the following tables.
# Programs which should not be installed will not be shown.
# Programs already installed and programs to be modified by thus
# installer will be noted.
#
# The following software will be installed
# Name      Version  Installation path
# COùòïCEPT   ...      "/..."
# CLASS     ...      "/..."
# FFTW      ...      "/..."
# FFTW      ...      "/..."
# FreeType  ...      "/..."
# Gadget    ...      "/..."
# GSL       ...      "/..."
# OpenBLAS  ...      "/..."
# HDF5      ...      "/..."
# libpng    ...      "/..."
# ncurses   ...      "/..."
# OpenSSL   ...      "/..."
# libffi    ...      "/..."
# Perl      ...      "/..."
# Python    ...      "/..."
# zlib      ...      "/..."
#
# The following Python packages will be installed
# Name          Version
# Blessings     ...
# Cython        ...
# CythonGSL     ...
# H5Py          ...
# Matplotlib    ...
# MPI4Py        ...
# Nose          ...
# NumPy         ...
# parameterized ...
# pytest        ...
# SciPy         ...
if [ "${install_anything}" == "yes" ]; then
    disable_status
    heading "Installation overview"
fi
# Print out software installation overview
if [ "${install_any_software}" == "yes" ]; then
    # Title
    table=("${esc_bold}Name${esc_normal}"    \
           "${esc_bold}Version${esc_normal}" \
           "${esc_bold}Installation path${esc_normal}")
    # COùòïCEPT
    if [ "${concept_install}" == "yes" ]; then
        table=("${table[@]}" "${esc_concept}$([ "${concept_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${concept_version}" "\"${concept_dir}\"")
    fi
    # CLASS
    if [ "${class_install}" == "yes" ]; then
        table=("${table[@]}" "CLASS$([ "${class_installed}" == "yes" ] && echo '‚Ä†' || :)"           \
                "${class_version}$([ "${class_installed}" == "no" ] && echo '*' || :)" \
                "\"${class_dir}\"")
    fi
    # FFTW
    if [ "${fftw_install}" == "yes" ]; then
        table=("${table[@]}" "FFTW$([ "${fftw_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${fftw_version}" "\"${fftw_dir}\"")
    fi
    # FFTW for gadget
    if [ "${fftw_for_gadget_install}" == "yes" ]; then
        table=("${table[@]}" "FFTW$([ "${fftw_for_gadget_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${fftw_for_gadget_version}" "\"${fftw_for_gadget_dir}\"")
    fi
    # FreeType
    if [ "${freetype_install}" == "yes" ]; then
        table=("${table[@]}" "FreeType$([ "${freetype_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${freetype_version}" "\"${freetype_dir}\"")
    fi
    # Gadget
    if [ "${gadget_install}" == "yes" ]; then
        table=("${table[@]}" "Gadget$([ "${gadget_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${gadget_version}" "\"${gadget_dir}\"")
    fi
    # GSL
    if [ "${gsl_install}" == "yes" ]; then
        table=("${table[@]}" "GSL$([ "${gsl_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${gsl_version}" "\"${gsl_dir}\"")
    fi
    # OpenBLAS
    if [ "${openblas_install}" == "yes" ]; then
        table=("${table[@]}" "OpenBLAS$([ "${openblas_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${openblas_version}" "\"${openblas_dir}\"")
    fi
    # HDF5
    if [ "${hdf5_install}" == "yes" ]; then
        table=("${table[@]}" "HDF5$([ "${hdf5_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${hdf5_version}" "\"${hdf5_dir}\"")
    fi
    # libpng
    if [ "${libpng_install}" == "yes" ]; then
        table=("${table[@]}" "libpng$([ "${libpng_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${libpng_version}" "\"${libpng_dir}\"")
    fi
    # MPICH/OpenMPI
    if [ "${mpi_install}" == "yes" ]; then
        if [ "${mpi}" == "mpich" ]; then
            table=("${table[@]}" "MPICH$([ "${mpi_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                    "${mpi_version}" "\"${mpi_dir}\"")
        elif [ "${mpi}" == "openmpi" ]; then
            table=("${table[@]}" "OpenMPI$([ "${mpi_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                    "${mpi_version}" "\"${mpi_dir}\"")
        fi
    fi
    # ncurses
    if [ "${ncurses_install}" == "yes" ]; then
        table=("${table[@]}" "ncurses$([ "${ncurses_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${ncurses_version}" "\"${ncurses_dir}\"")
    fi
    # OpenSSL
    if [ "${openssl_install}" == "yes" ]; then
        table=("${table[@]}" "OpenSSL$([ "${openssl_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${openssl_version}" "\"${openssl_dir}\"")
    fi
    # libffi
    if [ "${libffi_install}" == "yes" ]; then
        table=("${table[@]}" "libffi$([ "${libffi_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${libffi_version}" "\"${libffi_dir}\"")
    fi
    # Perl
    if [ "${perl_install}" == "yes" ]; then
        table=("${table[@]}" "Perl$([ "${perl_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${perl_version}" "\"${perl_dir}\"")
    fi
    # Python
    if [ "${python_install}" == "yes" ]; then
        table=("${table[@]}" "Python$([ "${python_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${python_version}" "\"${python_dir}\"")
    fi
    # zlib
    if [ "${zlib_install}" == "yes" ]; then
        table=("${table[@]}" "zlib$([ "${zlib_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${zlib_version}" "\"${zlib_dir}\"")
    fi
    echo "The following software will be installed"
    print_table table[@] 3
    N_to_be_patched=0
    for (( i=4; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *'*' ]]; then
            ((N_to_be_patched += 1))
        fi
    done
    N_installed=0
    for (( i=3; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *'‚Ä†' ]]; then
            ((N_installed += 1))
        fi
    done
fi

# Print out Python package installation overview
if [ "${install_any_pypackages}" == "yes" ]; then
    # Title
    table=("${esc_bold}Name${esc_normal}" "${esc_bold}Version${esc_normal}" "")
    # Blessings
    if [ "${blessings_install}" == "yes" ]; then
        table=("${table[@]}" "Blessings$([ "${blessings_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                "${blessings_version}" "")
    fi
    # Cython
    if [ "${cython_install}" == "yes" ]; then
           table=("${table[@]}" "Cython$([ "${cython_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                   "${cython_version}" "")
    fi
    # CythonGSL
    if [ "${cythongsl_install}" == "yes" ]; then
           table=("${table[@]}" "CythonGSL$([ "${cythongsl_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                   "${cythongsl_version}" "")
    fi
    # H5Py
    if [ "${h5py_install}" == "yes" ]; then
           table=("${table[@]}" "H5Py$([ "${h5py_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                   "${h5py_version}" "")
    fi
    # Matplotlib
    if [ "${matplotlib_install}" == "yes" ]; then
           table=("${table[@]}" "Matplotlib$([ "${matplotlib_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                   "${matplotlib_version}" "")
    fi
    # MPI4Py
    if [ "${mpi4py_install}" == "yes" ]; then
           table=("${table[@]}" "MPI4Py$([ "${mpi4py_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                   "${mpi4py_version}" "")
    fi
    # Nose
    if [ "${nose_install}" == "yes" ]; then
           table=("${table[@]}" "Nose$([ "${nose_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                   "${nose_version}" "")
    fi
    # NumPy
    if [ "${numpy_install}" == "yes" ]; then
           table=("${table[@]}" "NumPy$([ "${numpy_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                   "${numpy_version}" "")
    fi
    # parameterized
    if [ "${parameterized_install}" == "yes" ]; then
           table=("${table[@]}" "parameterized$([ "${parameterized_installed}" == "yes" ] \
                   && echo '‚Ä†' || :)" \
                   "${parameterized_version}" "")
    fi
    # Pytest
    if [ "${pytest_install}" == "yes" ]; then
           table=("${table[@]}" "pytest$([ "${pytest_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                   "${pytest_version}" "")
    fi
    # SciPy
    if [ "${scipy_install}" == "yes" ]; then
           table=("${table[@]}" "SciPy$([ "${scipy_installed}" == "yes" ] && echo '‚Ä†' || :)" \
                   "${scipy_version}" "")
    fi
    if [ "${install_any_software}" ]; then
        echo
    fi
    echo "The following Python packages will be installed"
    print_table table[@] 3
    for (( i=3; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *'‚Ä†' ]]; then
            ((N_installed += 1))
        fi
    done
    for (( i=4; i<${#table[@]}; i+=3 )); do
        if [[ "${table[i]}" == *'*' ]]; then
            ((N_to_be_patched += 1))
        fi
    done
fi
echo
if [ -n "${N_to_be_patched}" ]; then
    if [ ${N_to_be_patched} -eq 1 ]; then
        echo "* This will be patched by the installer"
    elif [ ${N_to_be_patched} -gt 1 ]; then
        echo "* These will be patched by the installer"
    fi
fi
if [ -n "${N_installed}" ]; then
    if [ ${N_installed} -eq 1 ]; then
        echo "‚Ä† This is already installed and will not be reinstalled"
    elif [ ${N_installed} -gt 1 ]; then
        echo "‚Ä† These are already installed and will not be reinstalled"
    fi
fi
if [ "${install_anything}" == "yes" ]; then
    sleep ${sleep_time}
    enable_status
fi



#################################
# Download COùòïCEPT dependencies #
#################################
# Function for downloading compressed archives
download(){
    # Arguments: Program name
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    # Do not download if already fully downloaded
    eval "prog_downloaded=\"\${${progname}_downloaded}\""
    if [ "${prog_downloaded}" == "yes" ]; then
        return
    fi
    eval "progversion=\"\${${progname}_version}\""
    if [ "${progname}" == "fftw_for_gadget" ]; then
        # When downloading FFTW for GADGET, the version number should
        # be printed together with FFTW, not GADGET.
        current_step="the downloading of FFTW ${progversion} for GADGET"
        heading "Downloading FFTW ${progversion} for GADGET"
    elif [ "${progname}" == "mpi" ]; then
        if [ "${mpi}" == "mpich" ]; then
            current_step="the downloading of MPICH ${progversion}"
            heading "Downloading MPICH ${progversion}"
        elif [ "${mpi}" == "openmpi" ]; then
            current_step="the downloading of OpenMPI ${progversion}"
            heading "Downloading OpenMPI ${progversion}"
        fi
    else
        current_step="the downloading of ${1/CONCEPT/$esc_concept} ${progversion}"
        heading "Downloading ${1/CONCEPT/$esc_concept} ${progversion}"
    fi
    eval "url=\"\${${progname}_url}\""
    # Download
    mkdir -p "${top_dir}/tmp/${progname}"
    cd "${top_dir}/tmp/${progname}"
    for n in {1..50}; do
        for ipv in "--inet4-only" "--inet6-only" ""; do
            wget_status="success"
            wget -t 1 --timeout 60 -c --no-check-certificate --no-dns-cache ${ipv} \
                 "${url}" || wget_status="error"
            if [ "${wget_status}" == "success" ]; then
                break
            fi
        done
        if [ "${wget_status}" == "success" ]; then
            break
        fi
        sleep 5
    done
    if [ "${wget_status}" == "error" ]; then
        error "Error downloading \"${url}\""
        exit 1
    fi
    # Write out success notice
    echo "The following has been fully downloaded:
File:    $(ls -t -1 | head -n 1)
URL:     ${url}
Program: ${progname}
Version: ${progversion}
Date:    $(date)
" > ".download_finished"
    cd "${top_dir}"
}

# Make the directory in which to dump all downloaded archives
mkdir -p "${top_dir}/tmp"
# Download the source code for all programs that should be installed
disable_status
if [ "${concept_install}"         == "yes" ] && [ "${concept_downloaded}"         == "no" ]; then
    download "CONCEPT"
fi
if [ "${class_install}"           == "yes" ] && [ "${class_downloaded}"           == "no" ]; then
    download "CLASS"
fi
if [ "${fftw_install}"            == "yes" ] && [ "${fftw_downloaded}"            == "no" ]; then
    download "FFTW"
fi
if [ "${fftw_for_gadget_install}" == "yes" ] && [ "${fftw_for_gadget_downloaded}" == "no" ]; then
    download "FFTW for GADGET"
fi
if [ "${freetype_install}"        == "yes" ] && [ "${freetype_downloaded}"        == "no" ]; then
    download "FreeType"
fi
if [ "${gadget_install}"          == "yes" ] && [ "${gadget_downloaded}"          == "no" ]; then
    download "GADGET"
fi
if [ "${gsl_install}"             == "yes" ] && [ "${gsl_downloaded}"             == "no" ]; then
    download "GSL"
fi
if [ "${hdf5_install}"            == "yes" ] && [ "${hdf5_downloaded}"            == "no" ]; then
    download "HDF5"
fi
if [ "${libpng_install}"          == "yes" ] && [ "${libpng_downloaded}"          == "no" ]; then
    download "libpng"
fi
if [ "${mpi_install}"             == "yes" ] && [ "${mpi_downloaded}"             == "no" ]; then
    download "MPI"
fi
if [ "${ncurses_install}"         == "yes" ] && [ "${ncurses_downloaded}"         == "no" ]; then
    download "ncurses"
fi
if [ "${openblas_install}"        == "yes" ] && [ "${openblas_downloaded}"        == "no" ]; then
    download "OpenBLAS"
fi
if [ "${openssl_install}"         == "yes" ] && [ "${openssl_downloaded}"         == "no" ]; then
    download "OpenSSL"
fi
if [ "${libffi_install}"          == "yes" ] && [ "${libffi_downloaded}"          == "no" ]; then
    download "libffi"
fi
if [ "${perl_install}"            == "yes" ] && [ "${perl_downloaded}"            == "no" ]; then
    download "Perl"
fi
if [ "${python_install}"          == "yes" ] && [ "${python_downloaded}"          == "no" ]; then
    download "Python"
fi
if [ "${zlib_install}"            == "yes" ] && [ "${zlib_downloaded}"            == "no" ]; then
    download "zlib"
fi
enable_status



################################
# Install COùòïCEPT dependencies #
################################
# Function for extracting compressed files
extract(){
    # Arguments: Program name, [is_file]
    # Here, the optional is_file argument can be set to "yes" if
    # the first argument is a filename rather than a program name.
    # In that case, the working directory will not be changed.
    if [ "$2" == "yes" ]; then
        archive="$1"
    else
        progname="${1// /_}"
        progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
        cd "${top_dir}/tmp/${progname}"
        # We assume that any directories placed here is from a similar
        # previous call which went wrong. Delete any of these
        # directories before extracting.
        n_files=0
        for f in *; do
            if [ -d "${f}" ]; then
                rm -rf "${f}"
            else
                archive="${f}"
                ((n_files += 1))
            fi
        done
        if [ -z "${archive}" ]; then
            error "Did not find any files in \"${top_dir}/tmp/${progname}\""
            exit 1
        elif [ ${n_files} -gt 1 ]; then
            error "Found multiple files in \"${top_dir}/tmp/${progname}\"."
            error "I am confused about which to extract. Exiting."
            exit 1
        fi
    fi
    case "${archive}" in
        # 7zip
        *.tar.7zip)  7z       -so  x   "${archive}" | tar -ixvf -;;
        *.tar.7z)    7z       -so  x   "${archive}" | tar -ixvf -;;
        *.t7zip)     7z       -so  x   "${archive}" | tar -ixvf -;;
        *.t7z)       7z       -so  x   "${archive}" | tar -ixvf -;;
        *.7zip)      7z            x   "${archive}"              ;;
        *.7z)        7z            x   "${archive}"              ;;
        # ar
        *.ar)        ar       -xv      "${archive}"              ;;
        *.a)         ar       -xv      "${archive}"              ;;
        # bzip2
        *.tar.bzip2) bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tar.bz2)   bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbzip2)    bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbz2)      bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.bzip2)     bzip2    -d       "${archive}"              ;;
        *.bz2)       bzip2    -d       "${archive}"              ;;
        *.tar.bzip)  bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tar.bz)    bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbzip)     bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.tbz)       bzip2    -d     < "${archive}" | tar -ixvf -;;
        *.bzip)      bzip2    -d       "${archive}"              ;;
        *.bz)        bzip2    -d       "${archive}"              ;;
        # cbz
        *.cbz)       unzip             "${archive}"              ;;
        # compress
        *.tar.Z)     compress -d     < "${archive}" | tar -ixvf -;;
        *.tZ)        compress -d     < "${archive}" | tar -ixvf -;;
        *.Z)         compress -d       "${archive}"              ;;
        # cpio
        *.cpio)      cpio     -idv     "${archive}"              ;;
        # exe
        *.exe)       "$(readlink -f    "${archive}")"            ;;
        # gzip
        *.tar.gzip)  gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.gz)    gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.z)     gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tgzip)     gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tgz)       gzip     -d     < "${archive}" | tar -ixvf -;;
        *.tz)        gzip     -d     < "${archive}" | tar -ixvf -;;
        *.gzip)      gzip     -d       "${archive}"              ;;
        *.gz)        gzip     -d       "${archive}"              ;;
        # iso
        *.7z)        7z            x   "${archive}"              ;;
        # jar
        *.jar)       jar      -xvf     "${archive}"              ;;
        # lzip
        *.tar.lzip)  lzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.lz)    lzip     -d     < "${archive}" | tar -ixvf -;;
        *.tlzip)     lzip     -d     < "${archive}" | tar -ixvf -;;
        *.tlz)       lzip     -d     < "${archive}" | tar -ixvf -;;
        *.lzip)      lzip     -d       "${archive}"              ;;
        *.lz)        lzip     -d       "${archive}"              ;;
        # lzma
        *.tar.lzma)  lzma     -d     < "${archive}" | tar -ixvf -;;
        *.tlzma)     lzma     -d     < "${archive}" | tar -ixvf -;;
        *.lzma)      lzma     -d       "${archive}"              ;;
        # lzop
        *.tar.lzop)  lzop     -d     < "${archive}" | tar -ixvf -;;
        *.tar.lzo)   lzop     -d     < "${archive}" | tar -ixvf -;;
        *.tlzop)     lzop     -d     < "${archive}" | tar -ixvf -;;
        *.tlzo)      lzop     -d     < "${archive}" | tar -ixvf -;;
        *.lzop)      lzop     -d       "${archive}"              ;;
        *.lzo)       lzop     -d       "${archive}"              ;;
        # pack
        *.z)         pack          u   "${archive}" out          ;;
        # rar
        *.rar)       unrar         x   "${archive}"              ;;
        # rzip
        *.tar.rzip)  rzip     -d     < "${archive}" | tar -ixvf -;;
        *.tar.rz)    rzip     -d     < "${archive}" | tar -ixvf -;;
        *.trzip)     rzip     -d     < "${archive}" | tar -ixvf -;;
        *.trz)       rzip     -d     < "${archive}" | tar -ixvf -;;
        *.rzip)      rzip     -d       "${archive}"              ;;
        *.rz)        rzip     -d       "${archive}"              ;;
        # shar
        *.shar)      unshar            "${archive}"              ;;
        # snappy
        *.sz)        snzip    -d       "${archive}"              ;;
        # tar
        *.tar)       cat               "${archive}" | tar -ixvf -;;
        # xz
        *.tar.xz)    xz       -d     < "${archive}" | tar -ixvf -;;
        *.txz)       xz       -d     < "${archive}" | tar -ixvf -;;
        *.xz)        xz       -d       "${archive}"              ;;
        # zip
        *tar.zip)    unzip    -p       "${archive}" | tar -ixvf -;;
        *tzip)       unzip    -p       "${archive}" | tar -ixvf -;;
        *.zip)       unzip             "${archive}"              ;;
        # unknown
        *) error "Could not understand the compression format of \"${archive}\""
           exit 1
           ;;
    esac
    if [ "$2" != "yes" ]; then
        cd "${top_dir}"
    fi
}

# Function which initializes installations (extracts the pre-
# downloaded archive and change to the extracted directory).
init_install(){
    # Arguments: Program name
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    eval "progversion=\"\${${progname}_version}\""
    if [ "${progname}" == "fftw_for_gadget" ]; then
        # When installing FFTW for GADGET, the version number should
        # be printed together with FFTW, not GADGET.
        current_step="the installation of FFTW ${progversion} for GADGET"
        heading "Installing FFTW ${progversion} for GADGET"
        set_status "Installing FFTW ${progversion} for GADGET"
    elif [ "${progname}" == "mpi" ]; then
        if [ "${mpi}" == "mpich" ]; then
            current_step="the installation of MPICH ${progversion}"
            heading "Installing MPICH ${progversion}"
            set_status "Installing MPICH ${progversion}"
        elif [ "${mpi}" == "openmpi" ]; then
            current_step="the installation of OpenMPI ${progversion}"
            heading "Installing OpenMPI ${progversion}"
            set_status "Installing OpenMPI ${progversion}"
        fi
    else
        current_step="the installation of ${1/CONCEPT/$esc_concept} ${progversion}"
        heading "Installing ${1/CONCEPT/$esc_concept} ${progversion}"
        set_status "Installing ${1/CONCEPT/$esc_concept_double_backslashes} ${progversion}"
    fi
    # Extract the downloaded archive
    extract "${progname}"
    # Change to the directory which contain the archive
    # and the extracted folder.
    cd "${top_dir}/tmp/${progname}"
    # The current directory should contain only a single directory.
    # Change to this directory.
    for f in *; do
        if [ -d "${f}" ]; then
            cd "${f}"
            break
        fi
    done
}

# Function for detecting when the current process appears to hang.
# When an apparent hang is detected, a soothing message is displaayed.
# This should be used when installing Python packages, as pip/setuptools
# sometimes has this bad hanging behaviour, especially for particular
# packages, such as h5py. This function should not be called in a
# situation where you do not believe that the hang is only apparent.
soothe(){
    # Argument: PID of background process on which to wait,
    # [time in seconds after which PID is killed].
    soothe_pid=$1
    kill_time=$2
    # A long wait is detected by repeatedly
    # checking the size of the log file generated
    # by this installation script.
    soothe_update_time=60
    (
    log_size_last=-1;                                                              \
    log_size=$(du -b "${log}" | awk '{print $1}');                                 \
    time_slept=0;                                                                  \
    while :; do                                                                    \
        sleep ${soothe_update_time};                                               \
        log_size_new=$(du -b "${log}" | awk '{print $1}');                         \
        if [ ${log_size} -eq ${log_size_new} ]; then                               \
            ((time_slept += ${soothe_update_time}));                               \
            if [ ${log_size} -ne ${log_size_last} ]; then                          \
                printf "\nThe next step may take an unreasonable amount of time.
Please be patient ...\n";                                                          \
                sleep 5;                                                           \
                log_size_new=$(du -b "${log}" | awk '{print $1}');                 \
                log_size_last=${log_size_new};                                     \
            elif [ -n "${kill_time}" ] && [ ${time_slept} -gt ${kill_time} ]; then \
                echo "Process assumed to be haning. Killing it";                   \
                kill -9 ${soothe_pid} >/dev/null 2>&1;                             \
                wait    ${soothe_pid} >/dev/null 2>&1;                             \
            fi;                                                                    \
        else                                                                       \
            time_slept=0;                                                          \
        fi;                                                                        \
        log_size=${log_size_new};                                                  \
    done                                                                           \
    ) & soothe_killer_pid=$!
    wait ${soothe_pid} >/dev/null 2>&1 || :
    kill ${soothe_killer_pid} >/dev/null 2>&1 || :  # No forcefull kill (no -9)
    wait ${soothe_killer_pid} >/dev/null 2>&1 || :
}

# zlib
if [ "${zlib_install}" == "yes" ] && [ "${zlib_installed}" == "no" ]; then
    init_install "zlib"
    ./configure --shared --prefix="${zlib_dir}" 2>&1
    if [ "${fast_install}" == "no" ]; then
        make ${make_jobs} test 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && zlib_test_success="no"
    fi
    zlib_test_log="${zlib_dir}/test_log"
    if [ "${zlib_test_success}" == "no" ]; then
        mkdir -p "${zlib_dir}"
        cp "test_log" "${zlib_test_log}"
    fi
    make ${make_jobs} install 2>&1
    cp "README" "${zlib_dir}/"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/zlib" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: zlib
Version: ${zlib_version}
Date:    $(date)
" >> "${zlib_dir}/.installation_finished"
fi

# libpng
if [ "${libpng_install}" == "yes" ] && [ "${libpng_installed}" == "no" ]; then
    init_install "libpng"
    export CPPFLAGS="-I${zlib_dir}/include ${CPPFLAGS}"
    export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
    export LDFLAGS="-L${zlib_dir}/lib ${LDFLAGS}"
    export ZLIBLIB="${zlib_dir}/lib"
    export ZLIBINC="${zlib_dir}/include"
    ./configure --prefix="${libpng_dir}" 2>&1
    if [ "${fast_install}" == "no" ]; then
        make ZLIBLIB="${ZLIBLIB}" ZLIBINC="${ZLIBINC}" ${make_jobs} check 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && libpng_test_success="no"
    fi
    libpng_test_log="${libpng_dir}/test_log"
    if [ "${libpng_test_success}" == "no" ]; then
        mkdir -p "${libpng_dir}"
        cp "test_log" "${libpng_test_log}"
    fi
    make ZLIBLIB="${ZLIBLIB}" ZLIBINC="${ZLIBINC}" ${make_jobs} install 2>&1
    reset_environment
    cp "LICENSE" "${libpng_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/libpng" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: libpng
Version: ${libpng_version}
Date:    $(date)
" >> "${libpng_dir}/.installation_finished"
fi

# GSL
if [ "${gsl_install}" == "yes" ] && [ "${gsl_installed}" == "no" ]; then
    init_install "GSL"
    ./configure --prefix="${gsl_dir}" 2>&1
    make ${make_jobs} 2>&1
    if [ "${fast_install}" == "no" ]; then
        make ${make_jobs} check 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && gsl_test_success="no"
    fi
    gsl_test_log="${gsl_dir}/test_log"
    if [ "${gsl_test_success}" == "no" ]; then
        mkdir -p "${gsl_dir}"
        cp "test_log" "${gsl_test_log}"
    fi
    make ${make_jobs} install 2>&1
    cp "COPYING" "README" "${gsl_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/gsl" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: GSL
Version: ${gsl_version}
Date:    $(date)
" >> "${gsl_dir}/.installation_finished"
fi

# MPI
if [ "${mpi_install}" == "yes" ] && [ "${mpi_installed}" == "no" ]; then
    if [ "${mpi}" == "mpich" ]; then
        # MPICH
        init_install "MPI"
        ./configure --enable-shared --prefix="${mpi_dir}" 2>&1
        make ${make_jobs} 2>&1
        make ${make_jobs} install 2>&1
        # MPICH can be tested by running the code below.
        # Since this require several GB of memory and will occupy up to
        # 30 MPI processes, we skip these tests.
        run_mpi_tests="no"
        if [ "${run_mpi_tests}" == "yes" ]; then
            if [ "${fast_install}" == "no" ]; then
                export RUNTESTS_VERBOSE=1
                make ${make_jobs} testing 2>&1 | tee "test_log"
                [ ${PIPESTATUS[0]} != 0 ] && mpi_test_success="no"
            fi
            mpi_test_log="${mpi_dir}/test_log"
            if [ "${mpi_test_success}" == "no" ]; then
                cp "test_log" "${mpi_test_log}"
            fi
            reset_environment
        fi
        cp "COPYRIGHT" "${mpi_dir}/" || :
        cd "${top_dir}"
        rm -rf "${top_dir}/tmp/mpi" || :
        # Write out success notice
        echo "The following has been fully installed:
Program: MPI
Version: ${mpi_version}
Date:    $(date)
" >> "${mpi_dir}/.installation_finished"
    elif [ "${mpi}" == "openmpi" ]; then
        # OpenMPI
        init_install "MPI"
        # Temporary OpenMPI session files can cause OpenMPI to crash.
        # Remove any temporary directory of the form
        # /tmp/openmpi-sessions-*
        # which belongs to the user.
        my_username="$(whoami)"
        ls_output="$(ls -l /tmp | grep openmpi-sessions- || :)"
        if [ -n "${ls_output}" ]; then
            while read -r line; do
                username="$(echo "${line}" | awk '{print $3}')"
                if [ "${username}" == "${my_username}" ]; then
                    openmpi_session_dirname="$(echo "${line}" | awk '{print $9}')"
                    rm -rf "/tmp/${openmpi_session_dirname}" || :
                fi
            done <<< "${ls_output}"
        fi
        # Install OpenMPI
        ./configure --prefix="${mpi_dir}" 2>&1
        make ${make_jobs} all 2>&1
        make ${make_jobs} install 2>&1
        # OpenMPI does not come with a test suite
        cp "AUTHORS" "LICENSE" "${mpi_dir}/" || :
        cd "${top_dir}"
        rm -rf "${top_dir}/tmp/mpi" || :
        # Write out success notice
        echo "The following has been fully installed:
Program: MPI
Version: ${mpi_version}
Date:    $(date)
" >> "${mpi_dir}/.installation_finished"
    fi
fi

# HDF5
if [ "${hdf5_install}" == "yes" ] && [ "${hdf5_installed}" == "no" ]; then
    init_install "HDF5"
    # Set environment variables and configure options used
    # when building againts MPI and zlib.
    enable_parallel=""
    if [ -n "${mpi_dir}" ]; then
        export CC="${mpi_dir}/bin/mpicc"
        for f in "mpic++" "mpicxx"; do
            if [ -f "${mpi_dir}/bin/${f}" ]; then
                export CXX="${mpi_dir}/bin/${f}"
                break
            fi
        done
        for f in "mpif90" "mpifort"; do
            if [ -f "${mpi_dir}/bin/${f}" ]; then
                export FC="${mpi_dir}/bin/${f}"
                export F9X="${FC}"
                break
            fi
        done
        export LD_LIBRARY_PATH="${mpi_dir}/lib:${LD_LIBRARY_PATH}"
        export PATH="${mpi_dir}/bin:${PATH}"
        enable_parallel="--enable-parallel"
    fi
    with_zlib=""
    if [ -n "${zlib_dir}" ]; then
        export LDFLAGS="-L${zlib_dir}/lib ${LDFLAGS}"
        export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
        export CFLAGS="-I${zlib_dir}/include ${CFLAGS}"
        with_zlib=--with-zlib="${zlib_dir}/include","${zlib_dir}/lib"
    fi
    ./configure                \
        --enable-shared        \
        ${enable_parallel}     \
        ${with_zlib}           \
        --prefix="${hdf5_dir}" \
        2>&1
    # Never versions of gcc (e.g. 8.1.0) do not allow attributes to be
    # specified after the declarator in function definitions. At least
    # in some versions of HDF5 (e.g. 1.10.2), this rule is broken by
    # src/H5detect.c. If the original build fail, we edit src/H5detect.c
    # to be compliant with this rule and try again.
    hdf5_make_success="yes"
    make ${make_jobs} 2>&1 || hdf5_make_success="no"
    if [ "${hdf5_make_success}" == "no" ]; then
        mv "src/H5detect.c" "src/H5detect.c_cp"
        if [ -z "${IFS+x}" ]; then
            IFS_ori="__unset__"
        else
            IFS_ori="${IFS}"
        fi
        IFS=''
        while read -r line; do
            if [ "${line}" == "static void" ] || [ "${line}" == "int" ] ; then
                printf "${line} " >> "src/H5detect.c"
            else
                echo "${line}" >> "src/H5detect.c"
            fi
        done <<< "$(cat "src/H5detect.c_cp")"
        if [ "${IFS_ori}" == "__unset__" ]; then
            unset IFS
        else
            IFS="${IFS_ori}"
        fi
        rm -f "src/H5detect.c_cp"
        sed -i 's/^static void \(.*\) HDF_NO_UBSAN/static void HDF_NO_UBSAN \1/' "src/H5detect.c"
        sed -i 's/^int \(.*\) HDF_NO_UBSAN/int HDF_NO_UBSAN \1/' "src/H5detect.c"
        hdf5_make_success="yes"
        make ${make_jobs} 2>&1 || hdf5_make_success="no"
    fi
    if [ "${hdf5_make_success}" == "no" ]; then
        error "Failed to make HDF5"
        exit 1
    fi
    # On some systems, the HDF5 test (make check) hangs indefinitely.
    # To counteract this, kill the process if it still runs after
    # ${hdf5_test_max_time} seconds. Count the test as failed if the
    # last line in test_log is not "make[1]: Leaving directory".
    if [ "${fast_install}" == "no" ]; then
        hdf5_test_max_time=3600
        # Perform serial + parallel tests if build against MPI
        # or normal tests otherwise.
        if [ -n "${mpi_dir}" ]; then
            # Serial tests
            (make ${make_jobs} check-s 2>&1 & echo $! >&3) 3> "hdf5_test_pid" \
                | tee "test_log" & tee_pid=$!
            sleep 1
            hdf5_test_pid="$(cat 'hdf5_test_pid')"
            rm -f "hdf5_test_pid"
            soothe ${hdf5_test_pid} ${hdf5_test_max_time}
            sleep 1
            kill -9 ${tee_pid} >/dev/null 2>&1 || :
            wait    ${tee_pid} >/dev/null 2>&1 || :
            # Measure success based on the last line of "test_log"
            if [ -z "$(  tail -n 1 test_log \
                       | grep 'make\[1\]: Leaving directory' 2> /dev/null)" ]; then
                hdf5_test_success="no"
            fi
            # Parallel tests
            (make ${make_jobs} check-p 2>&1 & echo $! >&3) 3> "hdf5_test_pid" \
                | tee -a "test_log" & tee_pid=$!
            sleep 1
            hdf5_test_pid="$(cat 'hdf5_test_pid')"
            rm -f "hdf5_test_pid"
            soothe ${hdf5_test_pid} ${hdf5_test_max_time}
            sleep 1
            kill -9 ${tee_pid} >/dev/null 2>&1 || :
            wait    ${tee_pid} >/dev/null 2>&1 || :
            # Measure success based on the last line of "test_log"
            if [ -z "$(  tail -n 1 test_log \
                       | grep 'make\[1\]: Leaving directory' 2> /dev/null)" ]; then
                hdf5_test_success="no"
            fi
        else
            (make ${make_jobs} check 2>&1 & echo $! >&3) 3> "hdf5_test_pid" \
                | tee "test_log" & tee_pid=$!
            sleep 1
            hdf5_test_pid="$(cat 'hdf5_test_pid')"
            rm -f "hdf5_test_pid"
            soothe ${hdf5_test_pid} ${hdf5_test_max_time}
            sleep 1
            kill -9 ${tee_pid} >/dev/null 2>&1 || :
            wait    ${tee_pid} >/dev/null 2>&1 || :
            # Measure success based on the last line of "test_log"
            if [ -z "$(tail -n 1 test_log \
                       | grep 'make\[1\]: ' 2> /dev/null)" ]; then
                hdf5_test_success="no"
            fi
        fi
    fi
    make ${make_jobs} install 2>&1
    if [ "${fast_install}" == "no" ]; then
        make ${make_jobs} check-install 2>&1 | tee -a "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && hdf5_test_success="no"
    fi
    hdf5_test_log="${hdf5_dir}/test_log"
    if [ "${hdf5_test_success}" == "no" ]; then
        mkdir -p "${hdf5_dir}"
        cp "test_log" "${hdf5_test_log}"
    fi
    reset_environment
    cp "COPYING" "README.txt" "${hdf5_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/hdf5" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: HDF5
Version: ${hdf5_version}
Date:    $(date)
" >> "${hdf5_dir}/.installation_finished"
fi

# FFTW
if [ "${fftw_install}" == "yes" ] && [ "${fftw_installed}" == "no" ]; then
    init_install "FFTW"
    # Set environment variables and configure options used
    # when building againts MPI.
    enable_mpi=""
    if [ -n "${mpi_dir}" ]; then
        export CC="${mpi_dir}/bin/mpicc"
        export CFLAGS="-O3 -fPIC ${CFLAGS}"
        export CPPFLAGS="-I${mpi_dir}/include ${CPPFLAGS}"
        export LDFLAGS="-L${mpi_dir}/lib ${LDFLAGS}"
        export MPICC="${mpi_dir}/bin/mpicc"
        export MPILIBS="-lmpi ${MPILIBS}"
        export PATH="${mpi_dir}/bin:${PATH}"
        enable_mpi="--enable-mpi"
    fi
    # Double-precision
    ./configure --enable-shared  \
                ${enable_mpi}    \
                --enable-openmp  \
                --enable-threads \
                --prefix="${fftw_dir}" 2>&1
    make ${make_jobs} 2>&1
    if [ "${fast_install}" == "no" ]; then
        make ${make_jobs} check 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && fftw_test_success="no"
    fi
    fftw_test_log="${fftw_dir}/test_log"
    if [ "${fftw_test_success}" == "no" ]; then
        mkdir -p "${fftw_dir}"
        cp "test_log" "${fftw_test_log}"
    fi
    make ${make_jobs} install 2>&1
    # Single-precision
    ./configure --enable-shared        \
                ${enable_mpi}          \
                --enable-openmp        \
                --enable-threads       \
                --prefix="${fftw_dir}" \
                --enable-float 2>&1
    make ${make_jobs} 2>&1
    make ${make_jobs} install 2>&1
    reset_environment
    cp "COPYING" "README" "${fftw_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/fftw" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: FFTW
Version: ${fftw_version}
Date:    $(date)
" >> "${fftw_dir}/.installation_finished"
fi

# FreeType
if [ "${freetype_install}" == "yes" ] && [ "${freetype_installed}" == "no" ]; then
    init_install "FreeType"
    ./configure --prefix="${freetype_dir}" \
                --with-zlib=no             \
                --with-bzip2=no            \
                --with-png=no              \
                --with-harfbuzz=no 2>&1
    make ${make_jobs} 2>&1
    # FreeType does not come with a test suite
    make ${make_jobs} install 2>&1
    (cd docs; cp "FTL.TXT" "GPLv2.TXT" "LICENSE.TXT" "${freetype_dir}/" || :)
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/freetype" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: FreeType
Version: ${freetype_version}
Date:    $(date)
" >> "${freetype_dir}/.installation_finished"
fi

# ncurses
if [ "${ncurses_install}" == "yes" ] && [ "${ncurses_installed}" == "no" ]; then
    init_install "ncurses"
    # Due to a bug in (at least) ncurses 6.0, this is needed on
    # some systems. See https://trac.sagemath.org/ticket/19762
    export CPPFLAGS="-P"
    ./configure --with-shared --prefix="${ncurses_dir}" 2>&1
    make ${make_jobs} 2>&1
    make ${make_jobs} install 2>&1
    if [ "${fast_install}" == "no" ]; then
        disable_status
        (sleep ${sleep_time}; echo "q") | "test/worm" -n 7 > "/dev/tty" 2>&1 \
            || ncurses_test_success="no"
        enable_status
    fi
    # Additional test run needed (if the first failed), as the one
    # above do not use tee (as it ruins the display).
    if [ "${fast_install}" == "no" ] && [ "${ncurses_test_success}" == "no" ]; then
        disable_status
        (sleep ${sleep_time}; echo "q") | "test/worm" -n 7 > "test_log" 2>&1 || :
        enable_status
    fi
    ncurses_test_log="${ncurses_dir}/include/ncurses/test_log"
    if [ "${ncurses_test_success}" == "no" ]; then
        mkdir -p "${ncurses_dir}/include/ncurses"
        cp "test_log" "${ncurses_test_log}"
    fi
    reset_environment
    cp "AUTHORS" "COPYING" "${ncurses_dir}/include/ncurses/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/ncurses" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: ncurses
Version: ${ncurses_version}
Date:    $(date)
" >> "${ncurses_dir}/.installation_finished"
fi

# Perl
if [ "${perl_install}" == "yes" ] && [ "${perl_installed}" == "no" ]; then
    init_install "Perl"
    # Sometimes make fails to build due to #include of poll.h from a
    # wrong location. A fix for this is implemented below. First we try
    # without the fix, then with the fix.
    # Furthermore, if no C compiler is explicitly set, the Configure
    # script will find one by itself. Using some C compilers
    # (e.g. craycc) may lead to failure, while gcc should be a safe
    # choice. Below we first specify gcc as the C compiler, and if this
    # does not work for whatever reason, we try again without specifying
    # the C compiler.
    for perl_poll_fix in "False" "True"; do
        for perl_c_compiler in "gcc" ""; do
            if [ -n "${perl_c_compiler}" ]; then
                ./Configure -de -Dprefix="${perl_dir}" -Dcc="${perl_c_compiler}" 2>&1 || :
            else
                ./Configure -de -Dprefix="${perl_dir}"                           2>&1 || :
            fi
            if [ "${perl_poll_fix}" == "True" ]; then
                sed -i 's/<poll\.h>/<sys\/poll\.h>/' "dist/IO/poll.h"
            fi
            perl_build_failed="False"
            make ${make_jobs} 2>&1 || perl_build_failed="True"
            if [ "${perl_build_failed}" == "False" ]; then
                break
            fi
            make distclean || :
        done
        if [ "${perl_build_failed}" == "False" ]; then
            break
        fi
    done
    if [ "${perl_build_failed}" == "True" ]; then
        error "Error installing Perl"
        exit 1
    fi
    if [ "${fast_install}" == "no" ]; then
        make ${make_jobs} test 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && perl_test_success="no"
    fi
    perl_test_log="${perl_dir}/test_log"
    if [ "${perl_test_success}" == "no" ]; then
        mkdir -p "${perl_dir}"
        cp "test_log" "${perl_test_log}"
    fi
    make ${make_jobs} install 2>&1
    cp "AUTHORS" "Copying" "README" "${perl_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/perl" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: Perl
Version: ${perl_version}
Date:    $(date)
" >> "${perl_dir}/.installation_finished"
fi

# OpenSSL
if [ "${openssl_install}" == "yes" ] && [ "${openssl_installed}" == "no" ]; then
    init_install "OpenSSL"
    export PATH="${perl_dir}/bin:${PATH}"
    export PERL="${perl_dir}/bin/perl"
    ./config shared --prefix="${openssl_dir}" --openssldir="${openssl_dir}/openssl" 2>&1
    make 2>&1  # Should not be run in parallel!
    if [ "${fast_install}" == "no" ]; then
        make test 2>&1 | tee "test_log"  # Should not be run in parallel!
        [ ${PIPESTATUS[0]} != 0 ] && openssl_test_success="no"
    fi
    openssl_test_log="${openssl_dir}/include/openssl/test_log"
    if [ "${openssl_test_success}" == "no" ]; then
        mkdir -p "${openssl_dir}/include/openssl"
        cp "test_log" "${openssl_test_log}"
    fi
    make install 2>&1  # Should not be run in parallel!
    reset_environment
    cp "LICENSE" "README" "${openssl_dir}/include/openssl/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/openssl" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: OpenSSL
Version: ${openssl_version}
Date:    $(date)
" >> "${openssl_dir}/.installation_finished"
fi

# libffi
if [ "${libffi_install}" == "yes" ] && [ "${libffi_installed}" == "no" ]; then
    init_install "libffi"
    ./configure --prefix="${libffi_dir}" 2>&1
    make ${make_jobs} 2>&1
    if [ "${fast_install}" == "no" ]; then
        make check 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && libffi_test_success="no"
    fi
    libffi_test_log="${libffi_dir}/lib/libffi-${libffi_version}/test_log"
    if [ "${libffi_test_success}" == "no" ]; then
        mkdir -p "${libffi_dir}/lib/libffi-${libffi_version}"
        cp "test_log" "${libffi_test_log}"
    fi
    make ${make_jobs} install 2>&1
    cp "LICENSE" "README" "${libffi_dir}/lib/libffi-${libffi_version}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/libffi" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: libffi
Version: ${libffi_version}
Date:    $(date)
" >> "${libffi_dir}/.installation_finished"
fi

# OpenBLAS
if [ "${openblas_install}" == "yes" ] && [ "${openblas_installed}" == "no" ]; then
    init_install "OpenBLAS"
    # Due to the threading behaviour of Python,
    # we install a non-threaded version of OpenBLAS.
    # Note that OpenBLAS runs its test suite during this build.
    make USE_THREAD=0 FC=gfortran || (make clean && make USE_THREAD=0)
    make PREFIX="${openblas_dir}" install
    cp "LICENSE" "${openblas_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/openblas" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: OpenBLAS
Version: ${openblas_version}
Date:    $(date)
" >> "${openblas_dir}/.installation_finished"
fi

# Python
if [ "${python_install}" == "yes" ] && [ "${python_installed}" == "no" ]; then
    init_install "Python"
    # Build with pip if both openssl and zlib are installed.
    # For Python >=3.7, a standalone libffi is also required,
    # though we do not check explicitly for this.
    with_ensurepip_install=""
    if [ -n "${openssl_dir}" ] && [ -n "${zlib_dir}" ]; then
        with_ensurepip_install="--with-ensurepip=install"
    fi
    # Try building with optimizations. If it fails for whatever reason,
    # fall back to a non-optimized build.
    for optimize_flag in "--enable-optimizations" ""; do
        if [ -z "${optimize_flag}" ]; then
            echo "Attempting to install Python without optimizations"
        else
            echo "Attempting to install Python with optimizations"
        fi
        pybuild_success="yes"
        # Set up environment variables and configure options
        reset_environment
        if [ -n "${ncurses_dir}" ]; then
            export CPPFLAGS="-I${ncurses_dir}/include -I${ncurses_dir}/include/ncurses ${CPPFLAGS}"
            export LD_LIBRARY_PATH="${ncurses_dir}/lib:${LD_LIBRARY_PATH}"
            export LDFLAGS="-L${ncurses_dir}/lib -Wl,-rpath=${ncurses_dir}/lib ${LDFLAGS}"
        fi
        with_openssl=""
        if [ -n "${openssl_dir}" ]; then
            export CPPFLAGS="-I${openssl_dir}/include/openssl ${CPPFLAGS}"
            export LD_LIBRARY_PATH="${openssl_dir}/lib:${LD_LIBRARY_PATH}"
            export LDFLAGS="-L${openssl_dir}/lib -Wl,-rpath=${openssl_dir}/lib ${LDFLAGS}"
            with_openssl="--with-openssl=${openssl_dir}"
            # Modify Modules/Setup.dist in order for Python to use the
            # custom SSL library.
            first_line="$(grep -n 'SSL=' 'Modules/Setup.dist')"
            first_line=${first_line%:*}
            ((last_line = first_line + 3))
            sed -i "${first_line},${last_line}s/.//" "Modules/Setup.dist"
            sed -i "${first_line}s/.*/SSL=${openssl_dir//\//\\/}/" "Modules/Setup.dist"
        fi
        if [ -n "${zlib_dir}" ]; then
            export CPPFLAGS="-I${zlib_dir}/include ${CPPFLAGS}"
            export LD_LIBRARY_PATH="${zlib_dir}/lib:${LD_LIBRARY_PATH}"
            export LDFLAGS="-L${zlib_dir}/lib -Wl,-rpath=${zlib_dir}/lib ${LDFLAGS}"
        fi
        with_system_ffi=""
        if [ -n "${libffi_dir}" ]; then
            current_dir="$(pwd)"
            for lib_dir in "lib" "lib64"; do
                if [ ! -d "${libffi_dir}/${lib_dir}" ]; then
                    continue
                fi
                cd "${libffi_dir}/${lib_dir}"
                for f in *; do
                    if     [ -d "${f}" ] \
                        && [[ "${f}" == "libffi"* ]] \
                        && [ -d "${libffi_dir}/${lib_dir}/${f}/include" ]; then
                        export CPPFLAGS="-I${libffi_dir}/${lib_dir}/${f}/include ${CPPFLAGS}"
                        break
                    fi
                done
                export LD_LIBRARY_PATH="${libffi_dir}/${lib_dir}:${LD_LIBRARY_PATH}"
                export LDFLAGS="-L${libffi_dir}/${lib_dir} \
-Wl,-rpath=${libffi_dir}/${lib_dir} ${LDFLAGS}"
            done
            cd "${current_dir}"
            with_system_ffi="--with-system-ffi"
        fi
        # Configure.
        # When optimizations are enabled, some of the tests which are
        # performed may hang. It appears that the configure script
        # allows each test to take up to an hour before they are
        # forcefully killed. We thus do not need to kill any such
        # hanging process manually. We do however write out a soothing
        # message in the case of such hangs, letting the user know that
        # everything is all right.
        ./configure --enable-shared ${optimize_flag} --prefix="${python_dir}" \
            ${with_ensurepip_install}                                         \
            ${with_openssl}                                                   \
            ${with_system_ffi}                                                \
            2>&1 || pybuild_success="no" & python_configure_pid=$!
        soothe ${python_configure_pid}
        if [ "${pybuild_success}" == "no" ]; then
            if [ -z "${optimize_flag}" ]; then
                echo "Error: Failed to install Python without optimizations"
            else
                echo "Error: Failed to install Python with optimizations"
            fi
            continue
        fi
        # Make
        make ${make_jobs} 2>&1 || pybuild_success="no"
        if [ "${pybuild_success}" == "no" ]; then
            if [ -z "${optimize_flag}" ]; then
                echo "Error: Failed to install Python without optimizations"
            else
                echo "Error: Failed to install Python with optimizations"
            fi
            continue
        fi
        # Test
        if [ "${fast_install}" == "no" ]; then
            make ${make_jobs} test 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} != 0 ] && python_test_success="no"
        fi
        python_test_log="${python_dir}/test_log"
        if [ "${python_test_success}" == "no" ]; then
            mkdir -p "${python_dir}"
            cp "test_log" "${python_test_log}"
        else
            rm -f "${python_test_log}"
        fi
        # Make install
        make install 2>&1 || pybuild_success="no"  # Should be run serially
        if [ "${pybuild_success}" == "no" ]; then
            if [ -z "${optimize_flag}" ]; then
                echo "Error: Failed to install Python without optimizations"
            else
                echo "Error: Failed to install Python with optimizations"
            fi
            continue
        else
            break
        fi
    done
    if [ "${pybuild_success}" == "no" ]; then
        error "Error: Failed to install Python, both with and without optimizations"
        exit 1
    fi
    reset_environment
    cp "LICENSE" "README.rst" "${python_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/python" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: Python
Version: ${python_version}
Date:    $(date)
" >> "${python_dir}/.installation_finished"
fi
# Create a python variable, storing the path to the Python interpreter
if [ -n "${python_dir}" ]; then
    for python_version_major in 3 2; do
        if [ -f "${python_dir}/bin/python${python_version_major}" ]; then
            break
        fi
    done
    python_version_major_dot_minor=$("${python_dir}/bin/python${python_version_major}" -c \
                                     "from sys import version_info as v; \
                                     print(str(v.major) + '.' + str(v.minor))")
    python="${python_dir}/bin/python${python_version_major_dot_minor}"
fi



###########################
# Install Python packages #
###########################
# Function that checks whether a given Python package
# is installed or not.
check_pypackage_installed(){
    # Arguments: Python package name
    "${python}" -c "
try:
    # CythonGSL has an extra underscore when importing
    if '${1}' == 'cythongsl':
        import cython_gsl
    else:
        import ${1}
    print('yes')
except:
    print('no')
" 2>/dev/null
}
# Set "pypackage"_installed variables
blessings_installed="no"
cython_installed="no"
cythongsl_installed="no"
h5py_installed="no"
matplotlib_installed="no"
mpi4py_installed="no"
nose_installed="no"
numpy_installed="no"
parameterized_installed="no"
pytest_installed="no"
scipy_installed="no"
if [ -n "${python}" ]; then
    for pypackage in blessings     \
                     cython        \
                     cythongsl     \
                     h5py          \
                     matplotlib    \
                     mpi4py        \
                     nose          \
                     numpy         \
                     parameterized \
                     pytest        \
                     scipy         \
                     pip; do
        pypackage_installed=$(check_pypackage_installed ${pypackage})
        eval "${pypackage}_installed=\"${pypackage_installed}\""
    done
fi

# Function for downloading Python packages, utilizing pip
pip_download(){
    # Arguments: Python package name, version, pip_download_time.
    # No second argument, blank second argument or a second argument of
    # "upgrade" means newest version. The second argument can also be a
    # version string that pip understands, e.g. ">=1.4".
    # The third argument determines how many seconds pip shoul get
    # to download the package before it is killed. This can be helpful
    # if pip (for whatever reason) desides to run the setup.py file of
    # the package after a successful download, and that process ends
    # up hanging. If no third argument is given, or if the third
    # argument is 0, no time limit is set.
    local command_end=""
    if [ -n "${2}" ] && [ "${2}" != "upgrade" ]; then
        if [[ "${2}" == [0-9]* ]]; then
            # Second argument is a specific version
            command_end="==${2}"
        else
            # Second argument is a version string that pip understands
            command_end="${2}"
        fi
    fi
    pip_name="${1//_/}"
    pip_name="$(echo "${pip_name}" | tr '[:upper:]' '[:lower:]')"
    tmp_pip_dir="${top_dir}/tmp/pip"
    mkdir -p "${tmp_pip_dir}"
    tmp_pip_dir="${tmp_pip_dir// /\\ }"  # Add backslashes before spaces
    # Maximum allowed time (in seconds) for download. After this time,
    # the download process will be killed. This is needed because the
    # process sometimes hang after an otherwise successful download.
    pip_download_time=3600
    if [ -n "${3}" ]; then
        pip_download_time=${3}
    fi
    # Download the Python package
    for n in {1..50}; do
        pip_status="error"
        # Dependent on the version of pip, different calling conventions
        # are used to download (and not install) the source code
        # of a Python package.
        for pip_args in "download -v -v -v
                                  --no-cache-dir
                                  --no-binary=:all:
                                  --dest=${tmp_pip_dir}
                                  ${pip_name}${command_end}" \
                        "install  -v -v -v
                                  --no-cache-dir
                                  --no-binary=:all:
                                  --download
                                  ${tmp_pip_dir}
                                  ${pip_name}${command_end}" \
                        "install  -v -v -v
                                  --no-cache-dir
                                  --no-use-wheel
                                  --download
                                  ${tmp_pip_dir}
                                  ${pip_name}${command_end}" \
                        "install  -v -v -v
                                  --no-use-wheel
                                  --download
                                  ${tmp_pip_dir}
                                  ${pip_name}${command_end}"; do
            # Download Python package
            "${python}" -m pip ${pip_args} & pip_download_pid=$!
            # The above command may succeed in retrieving the package,
            # but then hang indefinately. Kill the process after
            # ${pip_download_time} seconds.
            soothe ${pip_download_pid} ${pip_download_time}
            # If the archive exists in the tmp/pip dir,
            # the download completed successfully.
            if ls "${top_dir}/tmp/pip" | grep -i "${pip_name}" > /dev/null 2>&1; then
                pip_status="success"
            fi
            if [ "${pip_status}" == "success" ]; then
                break
            fi
        done
        if [ "${pip_status}" == "success" ]; then
            break
        fi
        sleep ${sleep_time}
    done
    if [ "${pip_status}" == "error" ]; then
        error "Error downloading ${1}"
        exit 1
    fi
}

# Function for installing and upgrading Python packages, utilizing pip
pip_install_pypackage(){
    # Arguments: Python package name, [version or "upgrade"]
    # (install specific version or update existing version to newest).
    # If second argument is not provided, the newest version
    # will be installed.
    local command_end=""
    if [ "${2}" == "upgrade" ]; then
        current_step="upgrade of ${1}"
        heading "Upgrading ${1}"
        set_status "Upgrading ${1}"
    else
        if [ -n "${2}" ]; then
            current_step="installation of ${1} ${2}"
            heading "Installing ${1} ${2}"
            set_status "Installing ${1} ${2}"
        else
            current_step="installation of ${1}"
            heading "Installing ${1}"
            set_status "Installing ${1}"
        fi
        if [ -n "${2}" ]; then
            command_end="==${2}"
        fi
    fi
    # Download Python package source
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
    mkdir -p "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pypackage="$(echo "${1}" | tr '[:upper:]' '[:lower:]')"
    pip_download "${pypackage}" "${2}"
    rm -rf "${tmp_pip_dir}_cp"
    cp -r "${tmp_pip_dir}" "${tmp_pip_dir}_cp"
    # Install Python package from source
    upgrade_flag=""
    if [ "${2}" == "upgrade" ]; then
        upgrade_flag="--upgrade"
    fi
    # After the adoption of PEP 518 (pip 10), some packages require
    # wheels (not bare source) when building. This can be disabled by
    # supplying --no-build-isolation. We try both.
    # Some times the installation process will appear to hang,
    # but it will eventually get going. This happens often for
    # particular packages, such as h5py. When this is the case,
    # write a soothing message.
    for extra_pip_arg in "" "--no-build-isolation"; do
        "${python}" -m pip install -v -v -v                          \
                                   ${extra_pip_arg}                  \
                                   -b "${tmp_pip_dir}/build"         \
                                   ${upgrade_flag}                   \
                                   --no-index                        \
                                   --find-links="${tmp_pip_dir}"     \
                                   "${pypackage}${command_end}" 2>&1 \
                                    & pip_install_pid=$!
        soothe ${pip_install_pid}
        pypackage_installed=$(check_pypackage_installed ${pypackage})
        if [ "${pypackage_installed}" == "yes" ]; then
            break
        fi
        if [ -z "${extra_pip_arg}" ]; then
            printf "\npip failed to install ${1}. Now trying with --no-build-isolation\n\n"
            rm -rf "${tmp_pip_dir}"
            cp -r "${tmp_pip_dir}_cp" "${tmp_pip_dir}"
        fi
    done
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_cp"
    # If we failed to install the Python package, try installing it
    # via pip without using any additional arguments.
    if [ "${pypackage_installed}" == "no" ]; then
        printf "\npip could not install/upgrade ${1}, neither with or without \
--no-build-isolation\nNow trying without specifying any extra arguments to pip\n\n"
        "${python}" -m pip install "${pypackage}${command_end}" 2>&1 & pip_install_pid=$!
        soothe ${pip_install_pid}
        pypackage_installed=$(check_pypackage_installed ${pypackage})
    fi
    reset_environment
    # Exit on failure
    if [ "${pypackage_installed}" == "no" ]; then
        error "pip could not install/upgrade ${1}"
        exit 1
    fi
    rm -rf "${tmp_pip_dir}_tmp"
}

# Upgrade pip and setuptools.
# Do not use the pip_download or pip_install_pypackage functions
# for this, as these packages (and their dependencies) may actually be
# needed for that to work, resulting in a bootstrapping problem.
# This problem really arises from the choice of installing Python
# packages from source. Let 'pip install' upgrade pip and setuptools
# by whatever means it wants, ensuring that the dependencies of these
# bootstrapping packages are installed/upgraded as well.
if [ "${pip_install}" == "yes" ] && [ "${python_installed}" == "no" ]; then
    tmp_pip_dir="${top_dir}/tmp/pip"
    export TMPDIR="${tmp_pip_dir}_tmp"
    for package in "pip" "setuptools"; do
        current_step="upgrade of ${package}"
        heading "Upgrading ${package}"
        set_status "Upgrading ${package}"
        eval "package_version=\${${package}_version}"
        # Dependent on the version of pip,
        # the --no-cache-dir option may be available or not.
        pip_success="yes"
        for extra_pip_arg in "--no-cache-dir" ""; do
            rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
            mkdir -p "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
            "${python}" -m pip install -v -v -v                  \
                                       ${extra_pip_arg}          \
                                       -b "${tmp_pip_dir}/build" \
                                       --upgrade                 \
                                       "${package}==${package_version}" 2>&1 || pip_success="no"
            if [ "${pip_success}" == "yes" ]; then
                break
            fi
        done
        # Exit on failure
        if [ "${pip_success}" == "no" ]; then
            error "Could not upgrade ${package}"
            exit 1
        fi
    done
    reset_environment
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
fi

# Upgrade all packages pre-installed
# with the newly installed Python distribution.
if [ "${python_install}" == "yes" ] && [ "${python_installed}" == "no" ]; then
    installed_packages_success="true"
    installed_packages="$("${python}" -m pip list --format=colu2mns 2>/dev/null)" \
        || installed_packages_success="false"
    if [ "${installed_packages_success}" == "false" ]; then
        installed_packages_success="true"
        installed_packages="$("${python}" -m pip list 2>/dev/null)" \
            || installed_packages_success="false"
    fi
    if [ "${installed_packages_success}" == "false" ]; then
        installed_packages="$("${python}" -c "
import pip
print('\n'.join([i.key for i in pip.get_installed_distributions()]))
")"
    fi
    installed_packages="$("${python}" -c "
packages = '''${installed_packages}'''.split('\n')
for i, package in enumerate(packages):
    if not package.strip().replace(' ', '').replace('-', ''):
        packages = packages[i+1:]
        break
print('\n'.join(packages))
" | awk '{print $1}')"
    while read package; do
        # No need to attempt updates of pip and setuptools,
        # as these have just been updated.
        if [ "${package}" == "pip" ] || [ "${package}" == "setuptools" ]; then
            continue
        fi
        # Attempt to update all other installed Python packages
        for n in {1..50}; do
            pip_success="yes"
            pip_install_pypackage "${package}" "upgrade" || pip_success="no"
            if [ "${pip_success}" == "yes" ]; then
                break
            fi
        done
    done <<< "${installed_packages}"
fi

# Install Python packages from PyPI

# Blessings
if [ "${blessings_install}" == "yes" ] && [ "${blessings_installed}" == "no" ]; then
    pip_install_pypackage "Blessings" "${blessings_version}"
fi

# Cython
if [ "${cython_install}" == "yes" ] && [ "${cython_installed}" == "no" ]; then
    pip_install_pypackage "Cython" "${cython_version}"
fi

# CythonGSL
if [ "${cythongsl_install}" == "yes" ] && [ "${cythongsl_installed}" == "no" ]; then
    export LD_LIBRARY_PATH="${gsl_dir}/lib:${LD_LIBRARY_PATH}"
    pip_install_pypackage "CythonGSL" "${cythongsl_version}"
    reset_environment
fi

# Nose
if [ "${nose_install}" == "yes" ] && [ "${nose_installed}" == "no" ]; then
    pip_install_pypackage "Nose" "${nose_version}"
fi

# parameterized
if (   [ "${parameterized_install}"   == "yes" ] \
    && [ "${parameterized_installed}" == "no" ]); then
    pip_install_pypackage "parameterized" "${parameterized_version}"
fi

# pytest
if [ "${pytest_install}" == "yes" ] && [ "${pytest_installed}" == "no" ]; then
    pip_install_pypackage "pytest" "${pytest_version}"
fi

# NumPy (manual invocation of setup.py is needed
# as we need to link to OpenBLAS).
if [ "${numpy_install}" == "yes" ] && [ "${numpy_installed}" == "no" ]; then
    current_step="installation of NumPy ${numpy_version}"
    heading "Installing NumPy ${numpy_version}"
    set_status "Installing NumPy ${numpy_version}"
    # Download NumPy
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
    mkdir -p "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pip_download "numpy" "${numpy_version}"
    cd "${tmp_pip_dir}"
    # It can happen that an archive format different from tar.gz is
    # downloaded, in which case the extraction will fail if the
    # corresponding tool is not installed. In that case, try to download
    # NumPy directly from GitHub
    extract "numpy"* "yes" || :
    numpy_extract_success="no"
    for f in *; do
        f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
        if [ -d "${f}" ] && [[ "${f_lower}" == "numpy"* ]]; then
            numpy_extract_success="yes"
            numpy_build_dir="${tmp_pip_dir}/${f}"
            break
        fi
    done
    if [ "${numpy_extract_success}" == "no" ]; then
        numpy_url="https://github.com/numpy/numpy/archive/v${numpy_version}.tar.gz"
        download "numpy"
        cd "${top_dir}/tmp/numpy"
        extract * "yes"
        for f in *; do
            f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
            if [ -d "${f}" ] && [[ "${f_lower}" == "numpy"* ]]; then
                numpy_build_dir="${top_dir}/tmp/numpy/${f}"
                break
            fi
        done
    fi
    # Create a site.cfg file containing information about OpenBLAS
    echo "[DEFAULT]
library_dirs = ${openblas_dir}/lib
include_dirs = ${openblas_dir}/include

[ALL]
library_dirs = ${openblas_dir}/lib
include_dirs = ${openblas_dir}/include

[atlas]
atlas_libs = openblas
libraries = openblas

[openblas]
libraries = openblas
library_dirs = ${openblas_dir}/lib
include_dirs = ${openblas_dir}/include
runtime_library_dirs = ${openblas_dir}/lib
" > "${numpy_build_dir}/site.cfg"
    # Build and install NumPy with OpenBLAS support.
    # We always use gfortran as the Fortran compiler.
    export BLAS="${openblas_dir}/lib/libopenblas.a"
    export LAPACK="${openblas_dir}/lib/libopenblas.a"
    export LD_LIBRARY_PATH="${openblas_dir}/lib:${LD_LIBRARY_PATH}"
    export FC=gfortran
    # On some systems, the Fortran compiler type and several additional
    # environment variables need to be modified. Here we try all
    # combinations until we hit a working combination.
    cp -r "${numpy_build_dir}" "${numpy_build_dir}_cp"
    LDFLAGS_ori="${LDFLAGS}"
    FFLAGS_ori="${FFLAGS}"
    for fcompiler in "gnu95" ""; do
        for extra_FFLAGS in "" "-fPIC"; do
            export FFLAGS="${extra_FFLAGS} ${FFLAGS_ori}"
            for extra_LDFLAGS in "" "-shared"; do
                export LDFLAGS="${extra_LDFLAGS} ${LDFLAGS_ori}"
                printf "\nAttempting to build NumPy with fcompiler=${fcompiler}, \
extra_FFLAGS=${extra_FFLAGS}, extra_LDFLAGS=${extra_LDFLAGS}\n"
                cd "${top_dir}"
                rm -rf "${numpy_build_dir}"
                cp -r "${numpy_build_dir}_cp" "${numpy_build_dir}"
                cd "${numpy_build_dir}"
                echo "yes" > ".setuppy_success"
                if [ -n "${fcompiler}" ]; then
                    ("${python}" setup.py build --fcompiler="${fcompiler}" \
                        || echo "no" > ".setuppy_success") & setuppy_pid=$!
                else
                    ("${python}" setup.py build \
                        || echo "no" > ".setuppy_success") & setuppy_pid=$!
                fi
                soothe ${setuppy_pid}
                sleep 1
                setuppy_success="$(cat '.setuppy_success')"
                if [ "${setuppy_success}" == "yes" ]; then
                    break
                else
                    printf "\nFailed to build NumPy with fcompiler=${fcompiler}, \
extra_FFLAGS=${extra_FFLAGS}, extra_LDFLAGS=${extra_LDFLAGS}\n"
                fi
            done
            if [ "${setuppy_success}" == "yes" ]; then
                break
            fi
        done
        if [ "${setuppy_success}" == "yes" ]; then
            break
        fi
    done
    if [ "${setuppy_success}" == "yes" ]; then
        printf "\nSuccessfully build NumPy with fcompiler=${fcompiler}, \
extra_FFLAGS=${extra_FFLAGS}, extra_LDFLAGS=${extra_LDFLAGS}\n\n"
    else
        error "NumPy build failed under all combinations of fcompiler, FFLAGS and LDFLAGS"
        exit 1
    fi
    "${python}" setup.py install & setuppy_pid=$!
    soothe ${setuppy_pid}
    reset_environment
    cd "${top_dir}"
    # Exit if installation failed
    if [ "$(check_pypackage_installed numpy)" == "no" ]; then
        error "Failed to install NumPy"
        exit 1
    fi
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp" "${top_dir}/tmp/numpy"
    # Test NumPy. The tests are considered successful on the basis on
    # the exit code only, meaning that only severe errors
    # (e.g. segmentation faults) will count as failures.
    if [ "${fast_install}" == "no" ]; then
        numpy_test_log="${python_dir}/numpy_test_log"
        "${python}" -c "import numpy; numpy.test('full', verbose=2)" 2>&1 \
            | tee "${numpy_test_log}"
        [ ${PIPESTATUS[0]} != 0 ] && numpy_test_success="no"
        if [ "${numpy_test_success}" == "yes" ]; then
            rm -f "${numpy_test_log}"
        fi
    fi
fi

# SciPy (manual invocation of setup.py is needed
# as we need to link to OpenBLAS).
if [ "${scipy_install}" == "yes" ] && [ "${scipy_installed}" == "no" ]; then
    current_step="installation of SciPy ${scipy_version}"
    heading "Installing SciPy ${scipy_version}"
    set_status "Installing SciPy ${scipy_version}"
    # Download SciPy
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
    mkdir -p "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pip_download "scipy" "${scipy_version}"
    cd "${tmp_pip_dir}"
    extract "scipy"* "yes"
    for f in *; do
        f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
        if [ -d "${f}" ] && [[ "${f_lower}" == "scipy"* ]]; then
            scipy_build_dir="${tmp_pip_dir}/${f}"
            break
        fi
    done
    # Create a site.cfg file containing information about OpenBLAS
    echo "[DEFAULT]
library_dirs = ${openblas_dir}/lib
include_dirs = ${openblas_dir}/include

[ALL]
library_dirs = ${openblas_dir}/lib
include_dirs = ${openblas_dir}/include

[atlas]
atlas_libs = openblas
libraries = openblas

[openblas]
libraries = openblas
library_dirs = ${openblas_dir}/lib
include_dirs = ${openblas_dir}/include
runtime_library_dirs = ${openblas_dir}/lib
" > "${scipy_build_dir}/site.cfg"
    # Build and install SciPy with OpenBLAS support.
    # We always use gfortran as the Fortran compiler.
    export BLAS="${openblas_dir}/lib/libopenblas.a"
    export LAPACK="${openblas_dir}/lib/libopenblas.a"
    export LD_LIBRARY_PATH="${openblas_dir}/lib:${LD_LIBRARY_PATH}"
    export FC=gfortran
    # On some systems, the Fortran compiler type and several additional
    # environment variables need to be modified. Here we try all
    # combinations until we hit a working combination.
    cp -r "${scipy_build_dir}" "${scipy_build_dir}_cp"
    LDFLAGS_ori="${LDFLAGS}"
    FFLAGS_ori="${FFLAGS}"
    for fcompiler in "gnu95" ""; do
        for extra_FFLAGS in "" "-fPIC"; do
            export FFLAGS="${extra_FFLAGS} ${FFLAGS_ori}"
            for extra_LDFLAGS in "" "-shared"; do
                export LDFLAGS="${extra_LDFLAGS} ${LDFLAGS_ori}"
                printf "\nAttempting to build SciPy with fcompiler=${fcompiler}, \
extra_FFLAGS=${extra_FFLAGS}, extra_LDFLAGS=${extra_LDFLAGS}\n"
                cd "${top_dir}"
                rm -rf "${scipy_build_dir}"
                cp -r "${scipy_build_dir}_cp" "${scipy_build_dir}"
                cd "${scipy_build_dir}"
                echo "yes" > ".setuppy_success"
                if [ -n "${fcompiler}" ]; then
                    ("${python}" setup.py build --fcompiler="${fcompiler}" \
                        || echo "no" > ".setuppy_success") & setuppy_pid=$!
                else
                    ("${python}" setup.py build \
                        || echo "no" > ".setuppy_success") & setuppy_pid=$!
                fi
                soothe ${setuppy_pid}
                sleep 1
                setuppy_success="$(cat '.setuppy_success')"
                if [ "${setuppy_success}" == "yes" ]; then
                    break
                else
                    printf "\nFailed to build SciPy with fcompiler=${fcompiler}, \
extra_FFLAGS=${extra_FFLAGS}, extra_LDFLAGS=${extra_LDFLAGS}\n"
                fi
            done
            if [ "${setuppy_success}" == "yes" ]; then
                break
            fi
        done
        if [ "${setuppy_success}" == "yes" ]; then
            break
        fi
    done
    if [ "${setuppy_success}" == "yes" ]; then
        printf "\nSuccessfully build SciPy with fcompiler=${fcompiler}, \
extra_FFLAGS=${extra_FFLAGS}, extra_LDFLAGS=${extra_LDFLAGS}\n\n"
    else
        error "SciPy build failed under all combinations of fcompiler, FFLAGS and LDFLAGS"
        exit 1
    fi
    "${python}" setup.py install & setuppy_pid=$!
    soothe ${setuppy_pid}
    reset_environment
    cd "${top_dir}"
    # Exit if installation failed
    if [ "$(check_pypackage_installed scipy)" == "no" ]; then
        error "Failed to install SciPy"
        exit 1
    fi
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
    # Test SciPy. The tests are considered successful on the basis on
    # the exit code only, meaning that only severe errors
    # (e.g. segmentation faults) will count as failures.
    if [ "${fast_install}" == "no" ]; then
        scipy_test_log="${python_dir}/scipy_test_log"
        "${python}" -c "import scipy; scipy.test('full', verbose=2)" 2>&1 \
            | tee "${scipy_test_log}"
        [ ${PIPESTATUS[0]} != 0 ] && scipy_test_success="no"
        if [ "${scipy_test_success}" == "yes" ]; then
            rm -f "${scipy_test_log}"
        fi
    fi
fi

# Matplotlib (as Matplotlib has a hard time finding FreeType,
# some hacks are needed).
if [ "${matplotlib_install}" == "yes" ] && [ "${matplotlib_installed}" == "no" ]; then
    current_step="installation of Matplotlib ${matplotlib_version}"
    heading "Installing Matplotlib ${matplotlib_version}"
    set_status "Installing Matplotlib ${matplotlib_version}"
    # Download matplotlib itself
    tmp_pip_dir="${top_dir}/tmp/pip"
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
    mkdir -p "${tmp_pip_dir}_tmp"
    export TMPDIR="${tmp_pip_dir}_tmp"
    pip_download "matplotlib" "${matplotlib_version}"
    # Matplotlib depends on other Python packages not directly used
    # by COùòïCEPT. Most often these dependencies are downloaded
    # automatically by the previous command. In case of failure,
    # we do it manually.
    if [ "${numpy_preinstalled}" == "yes" ] || [ "${numpy_install}" == "yes" ]; then
        # NumPy already installed
        deps=(                \
            "pyparsing"       \
            "python-dateutil" \
            "pytz"            \
            "cycler"          \
            "six"             \
            "kiwisolver"      \
        )
        # From http://matplotlib.org/users/installing.html and matplotlib's setupext.py
        dep_versions=(
            ">=2.0.1,!=2.0.4,!=2.1.2,!=2.1.6" \
            ">=2.1"                           \
            ""                                \
            ">=0.10.0"                        \
            ">=1.10"                          \
            ">=1.0.1"                         \
        )
    else
        # NumPy not installed. Add it as a matplotlib dependency
        deps=(                \
            "numpy"           \
            "pyparsing"       \
            "python-dateutil" \
            "pytz"            \
            "cycler"          \
            "six"             \
            "kiwisolver"      \
        )
        # From http://matplotlib.org/users/installing.html and matplotlib's setupext.py
        dep_versions=(
            ">=1.7.1"                         \
            ">=2.0.1,!=2.0.4,!=2.1.2,!=2.1.6" \
            ">=2.1"                           \
            ""                                \
            ">=0.10.0"                        \
            ">=1.10"                          \
            ">=1.0.1"                         \
        )
    fi
    # An illegal version of pyparsing may be downloaded by Matplotlib!
    pyparsing_downloaded="$(ls "${top_dir}/tmp/pip" | grep -i "pyparsing" || :)"
    illegal_pyparsings=("2.0.0" "2.0.4" "2.1.2" "2.1.6")
    for ((i=0; i<${#illegal_pyparsings[@]}; i+=1)); do
        if [[ "${pyparsing_downloaded}" == "pyparsing-${illegal_pyparsings[i]}"* ]]; then
            # Illegal pyparsing downloaded!
            rm -rf "${top_dir}/tmp/pip/pyparsing"*
            break
        fi
    done
    for ((i=0; i<${#deps[@]}; i+=1)); do
        if ! ls "${top_dir}/tmp/pip" | grep -i "${deps[i]}" > /dev/null 2>&1; then
            pip_download "${deps[i]}" "${dep_versions[i]}"
        fi
    done
    # Install matplotlib
    cd "${tmp_pip_dir}"
    extract "matplotlib"* "yes"
    for f in *; do
        f_lower="$(echo "${f}" | tr '[:upper:]' '[:lower:]')"
        if [ -d "${f}" ] && [[ "${f_lower}" == "matplotlib"* ]]; then
            cd "${f}"
            break
        fi
    done
    cp "setup.cfg.template" "setup.cfg"
    freetype_include2="$(echo "${freetype_dir}/include/freetype"* | awk '{print $NF}')"
    libpng_version_majors="$(echo "${libpng_version}" | grep -m 1 -o -P "[0-9]*\.[0-9]*" \
                                                              | head -n 1)"
    libpng_version_majors="$(echo "${libpng_version_majors//./}")"
    basedirlist="${freetype_dir},\
${freetype_dir}/include,\
${freetype_include2},\
${freetype_dir}/lib,\
${libpng_dir},\
${libpng_dir}/include,\
${libpng_dir}/lib,\
${libpng_dir}/include/libpng${libpng_version_majors},\
${zlib_dir},\
${zlib_dir}/include,\
${zlib_dir}/lib\
"
    sed -i "/basedirlist/c\basedirlist = ${basedirlist}" "setup.cfg"
    cp -r "${freetype_include2}/"* "${freetype_dir}/include/"
    export CPPFLAGS="-I${freetype_dir}/include                              \
                     -I${freetype_include2}                                 \
                     -I${libpng_dir}/include                                \
                     -I${libpng_dir}/include/libpng${libpng_version_majors} \
                     -I${zlib_dir}/include ${CPPFLAGS}"
    export LDFLAGS="-L${freetype_dir}/lib          \
                    -Wl,-rpath=${freetype_dir}/lib \
                    -L${libpng_dir}/lib            \
                    -Wl,-rpath=${libpng_dir}/lib   \
                    -L${zlib_dir}/lib              \
                    -Wl,-rpath=${zlib_dir}/lib ${LDFLAGS}"
    export PATH="${freetype_dir}/bin:${libpng_dir}/bin:${PATH}"
    export LD_LIBRARY_PATH="${libpng_dir}/lib:${zlib_dir}/lib:${LD_LIBRARY_PATH}"
    export PKG_CONFIG_PATH="${libpng_dir}/lib/pkgconfig:\
${zlib_dir}/lib/pkgconfig:${PKG_CONFIG_PATH}"
    # After the adoption of PEP 518 (pip 10), some packages require
    # wheels (not bare source) when building. This can be disabled by
    # supplying --no-build-isolation. We try both.
    # Some times the installation process will appear to hang,
    # but it will eventually get going. This happens often for
    # particular packages, such as h5py. When this is the case,
    # write a soothing message.
    for extra_pip_arg in "" "--no-build-isolation"; do
        "${python}" -m pip install -v -v -v                          \
                                   ${extra_pip_arg}                  \
                                   -b "${top_dir}/tmp/pip/build"     \
                                   --no-index                        \
                                   --find-links="${top_dir}/tmp/pip" \
                                   . 2>&1 & pip_install_pid=$!
        soothe ${pip_install_pid}
        # Some versions of Matplotlib (e.g. 2.2.2) mistakenly has the
        # _bz2 module as a hard dependency. Fix this issue.
        sed -i "s/^import bz2/try:\n    import bz2\nexcept:\n    pass/g" \
            "${python_dir}/lib/python${python_version_major_dot_minor}/\
site-packages/matplotlib/cbook/__init__.py" || :
        pypackage_installed=$(check_pypackage_installed matplotlib)
        if [ "${pypackage_installed}" == "yes" ]; then
            break
        fi
        if [ -z "${extra_pip_arg}" ]; then
            printf "\nFailed to install matplotlib. Now trying with --no-build-isolation \n\n"
        fi
    done
    reset_environment
    cd "${top_dir}"
    # Exit if installation failed
    if [ "${pypackage_installed}" == "no" ]; then
        error "Could not install matplotlib"
        exit 1
    fi
    rm -rf "${tmp_pip_dir}" "${tmp_pip_dir}_tmp"
fi

# MPI4Py
if [ "${mpi4py_install}" == "yes" ] && [ "${mpi4py_installed}" == "no" ]; then
    export PATH="${mpi_dir}/bin:${PATH}"
    pip_install_pypackage "MPI4Py" "${mpi4py_version}"
    reset_environment
fi

# H5Py (manual invocation of setup.py is needed
# as --mpi needs to be supplied).
if [ "${h5py_install}" == "yes" ] && [ "${h5py_installed}" == "no" ]; then
    export HDF5_DIR="${hdf5_dir}"
    export HDF5_MPI="ON"
    export CC="${mpi_dir}/bin/mpicc"
    pip_install_pypackage "h5py" "${h5py_version}"
    reset_environment
fi



###########################
# Install and patch CLASS #
###########################
if [ "${class_install}" == "yes" ] && [ "${class_installed}" == "no" ]; then
    init_install "CLASS"
    # Move the content of the current directory (the files of CLASS,
    # except .gitignore) to the CLASS installation directory.
    mkdir -p "${class_dir}"
    mv ./* "${class_dir}/"
    cd "${class_dir}"
    # Below we will do a lot of patching on the CLASS source code.
    # To aid us, we define the following function.
    patch_class(){
        filename="$1"
        linenr="$2"
        action="$3"
        new_lines="$4"
        # Add comments around inserted lines
        extension="${filename##*.}"
        if     [ "${extension}" == "c"   ] \
            || [ "${extension}" == "h"   ] \
            || [ "${extension}" == "cpp" ]; then
            new_lines=(""                      \
                "/************************/"   \
                "/* For use with CONCEPT */"   \
                "/************************/"   \
                "${new_lines[@]}"              \
                "/**************************/" \
                "/* ^For use with CONCEPT^ */" \
                "/**************************/" \
                ""                             \
            )
        elif   [ "${extension}" == "py"  ] \
            || [ "${extension}" == "pyx" ] \
            || [ "${extension}" == "pxd" ]; then
            new_lines=(""                    \
                "########################"   \
                "# For use with CONCEPT #"   \
                "########################"   \
                "${new_lines[@]}"            \
                "##########################" \
                "# ^For use with CONCEPT^ #" \
                "##########################" \
                ""                           \
            )
        fi
        # Find indentation at linenr
        indentation=""
        n_lines=$(wc -l "${filename}" | awk '{print $1}')
        ((n_lines_down = n_lines - linenr + 1))
        local IFS=''
        while read -r line; do
            if [ -n "${line// }" ]; then
                line_unindented="$(echo "${line}" | awk '{gsub(/^ +/,"")} {print $0}')"
                ((indentation_size = ${#line} - ${#line_unindented})) || :
                if [ "${line_unindented:0:1}" == "}" ]; then
                    ((indentation_size += 2))
                fi
                indentation="$(printf "%${indentation_size}s")"
                break
            fi
        done <<< "$(tail -n ${n_lines_down} "${filename}")"
        # Construct string of indented lines from the new_lines array
        new_line_nr=0
        for new_line in "${new_lines[@]}"; do
            if [ -n "${new_line}" ]; then
                indentation_use="${indentation}"
            else
                indentation_use=""
            fi
            if [ ${new_line_nr} -eq 0 ]; then
                new_lines_str="\\${indentation_use}${new_line}"
            else
                new_lines_str="${new_lines_str}\n${indentation_use}${new_line}"
            fi
            ((new_line_nr += 1))
        done
        # Insert the new lines in the file
        if [ "${action}" == "insert" ]; then
            sed -i "${linenr}i${new_lines_str}" "${filename}"
        elif [ "${action}" == "replace" ]; then
            sed -i "${linenr}d" "${filename}"
            sed -i "${linenr}i${new_lines_str}" "${filename}"
        fi
    }
    # Fix a double free bug
    pattern='free *\\( *pba *-> *q_ncdm *\\[ *k *\\] *\\) *;'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
             "${class_dir}/source/background.c" | head -n 1);
    ((linenr += 3))
    new_lines=("}")
    patch_class "${class_dir}/source/background.c" ${linenr} "insert" "${new_lines[@]}"
    ((linenr -= 3))
    new_lines=("if (pba->ncdm_quadrature_strategy[k] == qm_auto){")
    patch_class "${class_dir}/source/background.c" ${linenr} "insert" "${new_lines[@]}"
    # Change the values of some preprocessing directives
    # in header files, allowing larger inputs and outputs.
    # Specifically, these are the changes:
    # _MAXTITLESTRINGLENGTH_   = 10‚Å∂  (in include/common.h)
    # _LINE_LENGTH_MAX_        = 10‚Å¥  (in include/parser.h)
    # _ARGUMENT_LENGTH_MAX_    = 10‚Å¥  (in include/parser.h)
    # _MAX_NUMBER_OF_K_FILES_  = 10‚Åµ  (in include/perturbations.h)
    value=1000000
    sed -i "s/^\( *#define \+_MAXTITLESTRINGLENGTH_ \+\)[^ ]*\(.*\)*$/\1${value}\2/" \
           "${class_dir}/include/common.h"
    value=10000
    sed -i "s/^\( *#define \+_LINE_LENGTH_MAX_ \+\)[^ ]*\(.*\)*$/\1${value}\2/" \
           "${class_dir}/include/parser.h"
    value=10000
    sed -i "s/^\( *#define \+_ARGUMENT_LENGTH_MAX_ \+\)[^ ]*\(.*\)*$/\1${value}\2/" \
           "${class_dir}/include/parser.h"
    value=100000
    sed -i "s/^\( *#define \+_MAX_NUMBER_OF_K_FILES_ \+\)[^ ]*\(.*\)*$/\1${value}\2/" \
           "${class_dir}/include/perturbations.h"
    # As only the (relatively) late-time evolution is needed from CLASS,
    # we hardcode the perturbations output to only be printed here.
    a_min=0.001
    pattern=' +a *= *pvecback'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
             "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                  \
        "/* Only return output at late times */" \
        "double a_min = ${a_min};"               \
        "if (a < a_min)"                         \
        "  return _SUCCESS_;"                    \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    # The a = 1 results are not always printed out by CLASS. Fix this.
    pattern='\\( *verbose *> *0\\)'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
             "${class_dir}/tools/evolver_ndf15.c" | head -n 1)
    new_lines=(                                                             \
        "/* If we are printing variables, we must store the final point */" \
        "if (print_variables!=NULL){"                                       \
        "  class_call((*print_variables)(tnew, ynew+1, f0+1,"               \
        "    parameters_and_workspace_for_derivs, error_message),"          \
        "    error_message, error_message);"                                \
        "}"                                                                 \
    )
    patch_class "${class_dir}/tools/evolver_ndf15.c" ${linenr} "insert" "${new_lines[@]}"
    # Include ncdm Psi0[q] in perturbation output
    pattern=' *char +tmp *\\[ *40 *\\] *;'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
             "${class_dir}/source/perturbations.c" | head -n 1)
    new_lines=(           \
        "char tmp[1024];" \
        "int index_q;"    \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "replace" "${new_lines[@]}"
    pattern='sprintf *\\( *tmp *, *\"cs2_ncdm\\[%d\\]\" *, *n_ncdm *\\) *;'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
             "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 2))
    new_lines=(                                                                   \
        "/* Include ncdm Psi0[q] in perturbation output */"                       \
        "for (index_q=0; index_q<pba->q_size_ncdm[n_ncdm]; index_q++){"           \
        "  sprintf(tmp,\"Psi0[%d](%.16f)\",n_ncdm,pba->q_ncdm[n_ncdm][index_q]);" \
        "  class_store_columntitle(ppt->scalar_titles,tmp,_TRUE_);"               \
        "}"                                                                       \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    pattern='class_store_double *\\( *dataptr *, *delta_p_over_delta_rho_ncdm *\\[ *n_ncdm *\\] *,'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
             "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                                           \
        "/* Include ncdm Psi0[q] in perturbation output */"               \
        "if (ppw->approx[ppw->index_ap_ncdmfa] == (int)ncdmfa_on){"       \
        "  for (index_q=0; index_q<pba->q_size_ncdm[n_ncdm]; index_q++){" \
        "    class_store_double(dataptr, 0.0, _TRUE_, storeidx);"         \
        "  }"                                                             \
        "}"                                                               \
        "else{"                                                           \
        "  idx = ppw->pv->index_pt_psi0_ncdm1;"                           \
        "  for (index_q=0; index_q<pba->q_size_ncdm[n_ncdm]; index_q++){" \
        "    class_store_double(dataptr, y[idx], _TRUE_, storeidx);"      \
        "    /* Jump to next momentum bin */"                             \
        "    idx += (ppw->pv->l_max_ncdm[n_ncdm]+1);"                     \
        "  }"                                                             \
        "}"                                                               \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    # Include dark energy fluid in perturbation output
    new_class_perturbation_linenr(){
        if [ "${1}" == "perturb_prepare_output" ]; then
            pattern='ppt *-> *number_of_scalar_titles *='
            linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
                "${class_dir}/source/perturbations.c" | head -n 1)
            ((linenr -= 1))
        elif [ "${1}" == "perturb_print_variables" ]; then
            pattern="class_store_double *\\\\( *dataptr *, *theta_scf *, *pba *-> *has_scf *, \
*storeidx *\\\\)*;"
            linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
                "${class_dir}/source/perturbations.c" | head -n 1)
            n_lines_total=$(wc -l "${class_dir}/source/perturbations.c" | awk '{print $1}')
            ((n_lines_down = n_lines_total - linenr))
            local IFS=''
            while read -r line; do
                ((linenr += 1))
                if [[ "${line}" == "  }" ]]; then
                    break
                fi
            done <<< "$(tail -n ${n_lines_down} "${class_dir}/source/perturbations.c")"
        fi
        echo ${linenr}
    }
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                                     \
        "/* Include dark energy fluid in perturbation output */"                    \
        "class_store_columntitle(ppt->scalar_titles, \"delta_fld\", pba->has_fld);" \
        "class_store_columntitle(ppt->scalar_titles, \"theta_fld\", pba->has_fld);" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                                                   \
        "/* Include dark energy fluid in perturbation output */"                                  \
        "double w_fld, dw_over_da_fld, integral_fld, theta_fld;"                                  \
        "if (pba->has_fld){"                                                                      \
        "  class_call(background_w_fld(pba, a, &w_fld, &dw_over_da_fld, &integral_fld),"          \
        "    pba->error_message, ppt->error_message);"                                            \
        "  class_store_double(dataptr, ppw->delta_rho_fld/pvecback[pba->index_bg_rho_fld],"       \
        "    pba->has_fld, storeidx);"                                                            \
        "  theta_fld = ppw->rho_plus_p_theta_fld/((1. + w_fld)*pvecback[pba->index_bg_rho_fld]);" \
        "  class_store_double(dataptr, theta_fld, pba->has_fld, storeidx);"                       \
        "}"                                                                                       \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    # Include theta_tot in perturbation output
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                               \
        "/* Include theta_tot in perturbation output */"                      \
        "class_store_columntitle(ppt->scalar_titles, \"theta_tot\", _TRUE_);" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                                                \
        "/**"                                                                                  \
        " * Include theta_tot in perturbation output."                                         \
        " * We compute this as theta_tot = rho_plus_p_theta/rho_plus_p_tot."                   \
        " * We can reliably get rho_plus_p_tot using"                                          \
        " *   rho_plus_p_tot = -2./3.*pvecback[pba->index_bg_H_prime]/a+2./3.*pba->K/a/a"      \
        " * and we should be able to get rho_plus_p_theta from"                                \
        " *   ppw->rho_plus_p_theta"                                                           \
        " * However, when using evolver = 0, something goes wrong and ppw->rho_plus_p_theta"   \
        " * end up with slightly erroneous values."                                            \
        " * Here we simply compute both rho_plus_p_theta and rho_plus_p_tot"                   \
        " * by adding up the contribution from each species."                                  \
        " *"                                                                                   \
        " */"                                                                                  \
        "double theta_tot, rho_plus_p_tot, rho_plus_p_theta, rho_plus_p;"                      \
        "rho_plus_p_tot = 0.;"                                                                 \
        "rho_plus_p_theta = 0.;"                                                               \
        "/* Photons */"                                                                        \
        "rho_plus_p = (1. + 1./3.)*pvecback[pba->index_bg_rho_g];"                             \
        "rho_plus_p_tot += rho_plus_p;"                                                        \
        "rho_plus_p_theta += rho_plus_p*theta_g;"                                              \
        "/* Baryons */"                                                                        \
        "rho_plus_p = (1. + 0.)*pvecback[pba->index_bg_rho_b];"                                \
        "rho_plus_p_tot += rho_plus_p;"                                                        \
        "rho_plus_p_theta += rho_plus_p*theta_b;"                                              \
        "/* Ultra relativistic species */"                                                     \
        "if (pba->has_ur){"                                                                    \
        "  rho_plus_p = (1. + 1./3.)*pvecback[pba->index_bg_rho_ur];"                          \
        "  rho_plus_p_tot += rho_plus_p;"                                                      \
        "  rho_plus_p_theta += rho_plus_p*theta_ur;"                                           \
        "}"                                                                                    \
        "/* Cold dark matter */"                                                               \
        "if (pba->has_cdm){"                                                                   \
        "  rho_plus_p= (1. + 0.)*pvecback[pba->index_bg_rho_cdm];"                             \
        "  rho_plus_p_tot += rho_plus_p;"                                                      \
        "  rho_plus_p_theta += rho_plus_p*theta_cdm;"                                          \
        "}"                                                                                    \
        "/* Non-cold dark matter */"                                                           \
        "if ((pba->has_ncdm == _TRUE_) && ((ppt->has_density_transfers == _TRUE_)"             \
        "  || (ppt->has_velocity_transfers == _TRUE_) || (ppt->has_source_delta_m == _TRUE_))" \
        "){"                                                                                   \
        "  for (n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++){"                                    \
        "    rho_plus_p = (pvecback[pba->index_bg_rho_ncdm1+n_ncdm] "                          \
        "      + pvecback[pba->index_bg_p_ncdm1+n_ncdm]);"                                     \
        "    rho_plus_p_tot += rho_plus_p;"                                                    \
        "    rho_plus_p_theta += rho_plus_p*theta_ncdm[n_ncdm];"                               \
        "  }"                                                                                  \
        "}"                                                                                    \
        "/* Decaying cold dark matter */"                                                      \
        "if (pba->has_dcdm){"                                                                  \
        "  rho_plus_p = (1. + 0.)*pvecback[pba->index_bg_rho_dcdm];"                           \
        "  rho_plus_p_tot += rho_plus_p;"                                                      \
        "  rho_plus_p_theta += rho_plus_p*theta_dcdm;"                                         \
        "}"                                                                                    \
        "/* Dark radiation */"                                                             \
        "if (pba->has_dr){"                                                                    \
        "  rho_plus_p = (1. + 1./3.)*pvecback[pba->index_bg_rho_dr];"                          \
        "  rho_plus_p_tot += rho_plus_p;"                                                      \
        "  rho_plus_p_theta += rho_plus_p*theta_dr;"                                           \
        "}"                                                                                    \
        "/* Scalar field */"                                                                   \
        "if (pba->has_scf){"                                                                   \
        "  rho_plus_p = pvecback[pba->index_bg_rho_scf] + pvecback[pba->index_bg_p_scf];"      \
        "  rho_plus_p_tot += rho_plus_p;"                                                      \
        "  rho_plus_p_theta += rho_plus_p*theta_scf;"                                          \
        "}"                                                                                    \
        "/* Dark energy fluid */"                                                              \
        "if (pba->has_fld){"                                                                   \
        "  rho_plus_p_theta += ppw->rho_plus_p_theta_fld;"                                     \
        "  rho_plus_p_tot += (ppw->rho_plus_p_theta_fld)/theta_fld;"                           \
        "}"                                                                                    \
        "/* Compute and store theta_tot */"                                                    \
        "theta_tot = rho_plus_p_theta/rho_plus_p_tot;"                                         \
        "class_store_double(dataptr, theta_tot, _TRUE_, storeidx);"                            \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    # Include h_prime in perturbation output
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                                                \
        "/* Include h_prime in perturbation output */"                                         \
        "class_store_columntitle(ppt->scalar_titles, \"h_prime\", ppt->gauge == synchronous);" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                          \
        "/* Include h_prime in perturbation output */"                   \
        "class_store_double(dataptr, pvecmetric[ppw->index_mt_h_prime]," \
        "  ppt->gauge == synchronous, storeidx);"                        \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    # Include H_T_Nb_prime in perturbation output
    linenr=$(new_class_perturbation_linenr "perturb_prepare_output")
    new_lines=(                                                                  \
        "/* Include H_T_Nb_prime in perturbation output */"                      \
        "class_store_columntitle(ppt->scalar_titles, \"H_T_Nb_prime\", _TRUE_);" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    linenr=$(new_class_perturbation_linenr "perturb_print_variables")
    new_lines=(                                                                             \
        "/**"                                                                               \
        " * Include H_T_Nb_prime in perturbation output."                                   \
        " * Here we make use of rho_plus_p_tot defined earlier."                            \
        " *"                                                                                \
        " */"                                                                               \
        "double p_tot_prime = 0.0;"                                                         \
        "/* Photons */"                                                                     \
        " p_tot_prime += -4./3.*a*H*pvecback[pba->index_bg_rho_g];"                         \
        "/* Baryons have no pressure */"                                                    \
        "/* Ultra relativistic species */"                                                  \
        "if (pba->has_ur == _TRUE_)"                                                        \
        "  p_tot_prime += -4./3.*a*H*pvecback[pba->index_bg_rho_ur];"                       \
        "/* Cold dark matter has no pressure */"                                            \
        "/* Non-cold dark matter */"                                                        \
        "if (pba->has_ncdm == _TRUE_){"                                                     \
        "  for(n_ncdm=0; n_ncdm < pba->N_ncdm; n_ncdm++)"                                   \
        "    p_tot_prime += -a*H*(5*pvecback[pba->index_bg_p_ncdm1+n_ncdm] "                \
        "    - pvecback[pba->index_bg_pseudo_p_ncdm1+n_ncdm]);"                             \
        "}"                                                                                 \
        "/* Decaying cold dark matter has no pressure */"                                   \
        "/* Dark radiation */"                                                              \
        "if (pba->has_dr == _TRUE_)"                                                        \
        "  p_tot_prime += -4./3.*a*H*pvecback[pba->index_bg_rho_dr];"                       \
        "/* Scalar field */"                                                                \
        "if (pba->has_fld == _TRUE_){"                                                      \
        "  p_tot_prime += a*H*pvecback[pba->index_bg_rho_fld] "                             \
        "    *(a*dw_over_da_fld - 3*w_fld*(1 + w_fld));"                                    \
        "}"                                                                                 \
        "/* Dark energy fluid */"                                                           \
        "if (pba->has_scf == _TRUE_){"                                                      \
        "  p_tot_prime += -3*H/a*pvecback[pba->index_bg_phi_prime_scf] "                    \
        "    *pvecback[pba->index_bg_phi_prime_scf]"                                        \
        "    - 2./3.*pvecback[pba->index_bg_dV_scf]*pvecback[pba->index_bg_phi_prime_scf];" \
        "}"                                                                                 \
        "/* Lambda has constant pressure */"                                                \
        "double H_T_Nb_prime = 3*a*H/rho_plus_p_tot*( "                                     \
        "  -ppw->delta_p + p_tot_prime*ppw->rho_plus_p_theta/rho_plus_p_tot/(k*k) "         \
        "  + ppw->rho_plus_p_shear);"                                                       \
        "class_store_double(dataptr, H_T_Nb_prime, _TRUE_, storeidx);"                      \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    # Do not convert synchronous variables to Newtonian gauge
    pattern='converting *synchronous *variables *to *newtonian *ones'
    linenr=$(awk "\$0 ~ \"${pattern}\" {print NR}" \
             "${class_dir}/source/perturbations.c" | head -n 1)
    ((linenr += 1))
    new_lines=(                                           \
        "/* Do not convert to Newtonian gauge */"         \
        "if (0==1){  /* (ppt->gauge == synchronous) { */" \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "replace" "${new_lines[@]}"
    # Add integers 'node' and 'indentation' and use these to make CLASS
    # print out correctly indented (with regard to COùòïCEPT) status
    # updates during perturbation computations, when the
    # perturbations_verbose parameter is negative. The 'node' and
    # 'indentation' integers are added to the classy.Class initializer
    # as optional arguments and then stored in the 'background' struct.
    linenr_1="$(grep -n 'struct background' "${class_dir}/include/background.h" | head -n 1)"
    linenr_1="${linenr_1%%:*}"
    i=0
    while :; do
        ((i += 1))
        linenr_2="$(grep -n '};' "${class_dir}/include/background.h" | head -n ${i} | tail -n 1)"
        linenr_2="${linenr_2%%:*}"
        if [ ${linenr_2} -gt ${linenr_1} ]; then
            break
        fi
    done
    new_lines=(                                                              \
        "/* Used to print status updates during perturbation computation */" \
        "int node, indentation;"                                             \
    )
    patch_class "${class_dir}/include/background.h" ${linenr_2} "insert" "${new_lines[@]}"
    linenr="$(grep -n "__cinit__" "${class_dir}/python/classy.pyx")"
    linenr="${linenr%%:*}"
    sed -i "${linenr}s/.*/    def __cinit__(self, default=False, node=0, indentation=0):  \
    # Changed for use with CONCEPT/" "${class_dir}/python/classy.pyx"
    ((linenr += 1))
    new_lines=(                                  \
        "self.ba.node = <int>node"               \
        "self.ba.indentation = <int>indentation" \
    )
    patch_class "${class_dir}/python/classy.pyx" ${linenr} "insert" "${new_lines[@]}"
    linenr_1="$(grep -n 'cdef struct background:' "${class_dir}/python/cclassy.pxd")"
    linenr_1="${linenr_1%%:*}"
    i=0
    while :; do
        ((i += 1))
        linenr_2="$(grep -n 'cdef struct' "${class_dir}/python/cclassy.pxd" \
            | head -n ${i} | tail -n 1)"
        linenr_2="${linenr_2%%:*}"
        if [ ${linenr_2} -eq ${linenr_1} ]; then
            ((i += 1))
            linenr_2="$(grep -n 'cdef struct' "${class_dir}/python/cclassy.pxd" \
                | head -n ${i} | tail -n 1)"
            linenr_2="${linenr_2%%:*}"
            break
        fi
    done
    new_lines=(           \
        "int node"        \
        "int indentation" \
    )
    patch_class "${class_dir}/python/cclassy.pxd" ${linenr_2} "insert" "${new_lines[@]}"
    linenr="$(grep -n 'for (index_k = ppt->k_size\[index_md\]-1; index_k >=0; index_k--)' \
        "${class_dir}/source/perturbations.c")"
    linenr="${linenr%%:*}"
    ((linenr += 1))
    new_lines=(                                                         \
        "if ((abort == _FALSE_) && (ppt->perturbations_verbose < 0)) {" \
        "  printf("                                                     \
        "    \"%*sNode %d: Evolving mode k = %e/Mpc (%d/%d)\\\\n\","    \

        "    pba->indentation, \"\","                                   \
        "    pba->node,"                                                \
        "    ppt->k[index_md][index_k],"                                \
        "    index_k+1,"                                                \
        "    ppt->k_size[index_md]"                                     \
        "  );"                                                          \
        "}"                                                             \
    )
    patch_class "${class_dir}/source/perturbations.c" ${linenr} "insert" "${new_lines[@]}"
    # Build CLASS, including the Python wrapper classy
    PYTHON="${python}" make ${make_jobs} 2>&1
    # Test CLASS
    if [ "${fast_install}" == "no" ]; then
        # We do not use the builtin test_class.py,
        # as this require tens of gigabytes.
        run_class_tests="no"
        if [ "${run_class_tests}" == "yes" ]; then
            "${python}" -m nose "python/test_class.py" 2>&1 | tee "test_log"
            [ ${PIPESTATUS[0]} != 0 ] && class_test_success="no"
            class_test_log="${class_dir}/test_log"
            if [ "${class_test_success}" == "no" ]; then
                cp "test_log" "${class_test_log}"
            fi
        else
            # Custom test which simply compute the background
            if ! "${python}" -c "import sys
from classy import Class
cosmo = Class()
cosmo.compute()
sys.exit(int(cosmo.get_background()['proper time [Gyr]'][-1]) != 13)
"; then
                class_test_success="no"
            fi
            class_test_log="${class_dir}/test_log"
            if [ "${class_test_success}" == "no" ]; then
                echo "CLASS did not pass a simple background computation test" \
                   > "${class_test_log}"
            fi
        fi
    fi
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/class" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: CLASS
Version: ${class_version}
Date:    $(date)
" >> "${class_dir}/.installation_finished"
fi



###################################
# Install the COùòïCEPT code itself #
###################################
# Paths used by COùòïCEPT
concept="${concept_dir}/concept"
ics_dir="${concept_dir}/ICs"
logs_dir="${concept_dir}/logs"
output_dir="${concept_dir}/output"
params_dir="${concept_dir}/params"
reusables_dir="${concept_dir}/.reusables"
tests_dir="${concept_dir}/tests"
utilities_dir="${concept_dir}/utilities"
Gadget2_dir="${gadget_dir}/Gadget2"
installer="${top_dir}/installer"
mpicc="${mpi_dir}/bin/mpicc"
mpiexec="${mpi_dir}/bin/mpiexec"
# Move source files, create empty directories and create the .paths file
if [ "${concept_install}" == "yes" ] && [ "${concept_installed}" == "no" ]; then
    init_install "CONCEPT"
    # Move everything from the concept-${concept_version}
    # directory to ${top_dir}.
    mv ./{.[!.],}* "${top_dir}/"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/concept" || :
    # Create directories
    mkdir -p "${ics_dir}"
    mkdir -p "${logs_dir}"
    mkdir -p "${output_dir}"
    mkdir -p "${params_dir}"
    # Add PATH-like environment variables present at install time (now)
    # to the .env file.
    current_step="addition of PATH-like environment variables to the .env file"
    printf "\nAdding PATH-like environment variables to .env\n"
    set_status "Adding PATH-like environment variables to .env"
    "${python}" -c "
import os
with open('${env_file}', 'r', encoding='utf-8') as file:
    lines = file.readlines()
# Generator for extracting environment variables
def get_envs():
    for var, val in os.environ.items():
        if (# PATH, LD_LIBRARY_PATH, ...
               ('path' in var.lower() and (val.startswith('/') or val.startswith(':')))
            # INTEL_LICENSE_FILE
            or (var == 'INTEL_LICENSE_FILE' and val.startswith('/'))
            ):
            yield var, val
# Add environment variables
envs_inserted = False
with open('${env_file}', 'w', encoding='utf-8') as file:
    for line in lines:
        if not envs_inserted and 'Update the environment' in line:
            print('# The following has been placed by the installer script.', file=file)
            print('# These were the PATH-like environment variables', file=file)
            print('# set at install time.', file=file)
            print('pathenv_name_value_pairs_installtime=( \\\\', file=file)
            for var, val in get_envs():
                print(f'    {var} \"{val}\" \\\\', file=file)
            print(')', file=file)
            print('', file=file)
            envs_inserted = True
        print(line, end='', file=file)
"
    # Create the .paths file,
    # storing important paths used by COùòïCEPT.
    current_step="creation of the .paths file"
    printf "\nWriting paths to .paths\n"
    set_status "Writing paths to .paths"
    echo "# This file contains absolute paths to directories and files
# used by the COùòïCEPT code. You may manually edit these paths.

#######################
# COùòïCEPT directories #
#######################
# Directory containing the source code
concept_dir='${concept_dir}'
# Directory intended for initial conditions
ics_dir='${ics_dir}'
# Directory containing the log files
logs_dir='${logs_dir}'
# Directory intended for output
output_dir='${output_dir}'
# Directory intended for parameter files
params_dir='${params_dir}'
# Directory containing various reusable dumps
reusables_dir='${reusables_dir}'
# Directory containing tests
tests_dir='${tests_dir}'
# Top level directory, containing e.g. README.md
top_dir='${top_dir}'
# Directory containing utilities
utilities_dir='${utilities_dir}'

##########################
# Dependency directories #
##########################
# Directory of CLASS
class_dir='${class_dir}'
# Directory of FFTW
fftw_dir='${fftw_dir}'
# Directory of FFTW2, used by GADGET
fftw_for_gadget_dir='${fftw_for_gadget_dir}'
# Directory of Gadget2
gadget_dir='${gadget_dir}'
# Directory containing the GADGET2 source code
Gadget2_dir='${Gadget2_dir}'
# Directory of GSL
gsl_dir='${gsl_dir}'
# Directory of HDF5
hdf5_dir='${hdf5_dir}'
# Directory of libpng
libpng_dir='${libpng_dir}'
# Directory of MPI
mpi_dir='${mpi_dir}'
# Directory of Python
python_dir='${python_dir}'
# Directory of zlib
zlib_dir='${zlib_dir}'

#########
# Files #
#########
# The executable script of the COùòïCEPT code
concept='${concept}'
# The file containing environment variables
env_file='${env_file}'
# The installer script
installer='${installer}'
# The MPI C compiler
mpicc='${mpicc}'
# The MPI executable
mpiexec='${mpiexec}'
# The file containing paths (this file)
paths_file='${paths_file}'
# The Python interpreter
python='${python}'
" > "${paths_file}"
    # COùòïCEPT will be tested later
fi



#####################################################
# Install GADGET, used for testing the COùòïCEPT code #
#####################################################
# FFTW 2.x (GADGET2 is incompatible with FFTW 3.x)
if [ "${fftw_for_gadget_install}" == "yes" ] && [ "${fftw_for_gadget_installed}" == "no" ]; then
    init_install "FFTW for GADGET"
    export CC="${mpi_dir}/bin/mpicc"
    export MPICC="${mpi_dir}/bin/mpicc"
    export CFLAGS="-O3 -fPIC"
    export CPPFLAGS="-I${mpi_dir}/include"
    export LDFLAGS="-L${mpi_dir}/lib"
    export MPILIBS="-lmpi"
    export PATH="${mpi_dir}/bin:${PATH}"
    # Double-precision
    ./configure --enable-shared      \
                --enable-mpi         \
                --enable-openmp      \
                --enable-threads     \
                --enable-type-prefix \
                --prefix="${fftw_for_gadget_dir}" 2>&1
    make ${make_jobs} 2>&1
    if [ "${fast_install}" == "no" ]; then
        make ${make_jobs} check 2>&1 | tee "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && fftw_for_gadget_test_success="no"
    fi
    make ${make_jobs} install 2>&1
    # Single-precision
    make ${make_jobs} clean
    ./configure --enable-shared      \
                --enable-mpi         \
                --enable-openmp      \
                --enable-threads     \
                --enable-float       \
                --enable-type-prefix \
                --prefix="${fftw_for_gadget_dir}" 2>&1
    make ${make_jobs} 2>&1
    if [ "${fast_install}" == "no" ]; then
        make ${make_jobs} check 2>&1 | tee -a "test_log"
        [ ${PIPESTATUS[0]} != 0 ] && fftw_for_gadget_test_success="no"
    fi
    fftw_for_gadget_test_log="${fftw_for_gadget_dir}/test_log"
    if [ "${fftw_for_gadget_test_success}" == "no" ]; then
        mkdir -p "${fftw_for_gadget_dir}"
        cp "test_log" "${fftw_for_gadget_test_log}"
    fi
    make ${make_jobs} install 2>&1
    reset_environment
    cp "COPYING" "README" "${fftw_for_gadget_dir}/" || :
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/fftw_for_gadget" || :
    # Write out success notice
    echo "The following has been fully installed:
Program: FFTW for GADGET
Version: ${fftw_for_gadget_version}
Date:    $(date)
" >> "${fftw_for_gadget_dir}/.installation_finished"
fi

# GADGET
if [ "${gadget_install}" == "yes" ] && [ "${gadget_installed}" == "no" ]; then
    init_install "GADGET"
    mkdir -p "${gadget_dir}"
    mv ./* "${gadget_dir}/"
    cd "${top_dir}"
    rm -rf "${top_dir}/tmp/gadget" || :
    # GADGET will be tested as part of the COùòïCEPT test suite.
    # Write out success notice.
    echo "The following has been fully installed:
Program: GADGET
Version: ${gadget_version}
Date:    $(date)
" >> "${gadget_dir}/.installation_finished"
fi



##############################
# Testing GADGET and COùòïCEPT #
##############################
if [ "${fast_install}" == "no" ] && [ "${concept_install}" == "yes" ] \
                                 && [ "${concept_installed}" == "no" ]; then
    # Run basic COùòïCEPT test to test the environment
    current_step="basic test of ${esc_concept}"
    heading "Basic test of ${esc_concept}"
    set_status "Basic test of ${esc_concept_double_backslashes}"
    cd "${concept_dir}"
    concept_test_log="${concept_dir}/test_log"
    "${concept}" -t "basic" 2>&1 | tee "${concept_test_log}"
    [ ${PIPESTATUS[0]} != 0 ] && concept_test_success="no"
    if  [ "${gadget_install}" == "yes" ]; then
        # Run GADGET test if basic COùòïCEPT test finished successfully
        if [ "${concept_test_success}" == "yes" ]; then
            current_step="testing GADGET"
            heading "Testing GADGET"
            set_status "Testing GADGET"
            gadget_test_log="${gadget_dir}/test_log"
            "${concept}" -t "gadget" 2>&1 | tee "${gadget_test_log}"
            [ ${PIPESTATUS[0]} != 0 ] && gadget_test_success="no"
            # Clean test_log if test is successfull
            if [ "${gadget_test_success}" == "yes" ]; then
                rm -f "${gadget_test_log}"
            fi
        fi
        # Run complete COùòïCEPT test suite if basic COùòïCEPT test
        # finished successfully.
        if [ "${concept_test_success}" == "yes" ]; then
            current_step="testing ${esc_concept}"
            heading "Testing ${esc_concept}"
            set_status "Testing ${esc_concept_double_backslashes}"
            "${concept}" -t "all" 2>&1 | tee "${concept_test_log}"
            [ ${PIPESTATUS[0]} != 0 ] && concept_test_success="no"
            # Clean test_log if test is successfull
            if [ "${concept_test_success}" == "yes" ]; then
                rm -f "${concept_test_log}"
                make distclean
            fi
        fi
    fi
    cd "${top_dir}"
    # Write out success notice. Place it in the GADGET directory
    # in order to minimize the number of files in the COùòïCEPT directory.
    echo "The following has been fully installed:
Program: CONCEPT
Version: ${concept_version}
Date:    $(date)
" >> "${gadget_dir}/.installation_finished"
fi



#############################
# Final cleanup and notices #
#############################
# Make sure that the tmp directory is removed. This may fail on clusters
# with the nfs file system ("Device or resource busy") due to still
# running background processes holding .nfs... files open.
rm -rf "${top_dir}/tmp" || :
# Remove the Python cache generated by all the Python invocations
# during the install.
rm -rf "${top_dir}/__pycache__"
# For some reason, one of the installations leave a file called
# _configtest.o.d in the top directory. Remove this.
rm -f "${top_dir}/_configtest"*
# Copyright notice
disable_status
copyright_notice(){
    # Arguments: Program/package name, text if installed by this script
    if eval "[ \"\${${1}_install}\" == \"yes\" ]"; then
        printf "${2}\n"
    fi
}
if [ "${install_anything}" == "yes" ]; then
    current_step="copyright notice"
    heading "Copyright notice"
    if [ "${concept_install}" == "yes" ]; then
        printf "${esc_concept} has been installed along with the following dependencies:\n"
    else
        printf "The following software have been installed:\n"
    fi
    copyright_notice "class"           "CLASS"
    copyright_notice "fftw"            "FFTW 3"
    copyright_notice "fftw_for_gadget" "FFTW 2"
    copyright_notice "freetype"        "FreeType"
    copyright_notice "gadget"          "GADGET"
    copyright_notice "gsl"             "GSL"
    copyright_notice "hdf5"            "HDF5"
    copyright_notice "libpng"          "libpng"
    if [ "${mpi}" == "mpich" ]; then
        copyright_notice "mpi"         "MPICH"
    elif [ "${mpi}" == "openmpi" ]; then
        copyright_notice "mpi"         "OpenMPI"
    fi
    copyright_notice "ncurses"         "ncurses"
    copyright_notice "openblas"        "OpenBLAS"
    copyright_notice "openssl"         "OpenSSL"
    copyright_notice "perl"            "Perl"
    copyright_notice "zlib"            "zlib"
    copyright_notice "python"          "Python"
    copyright_notice "blessings"       "$(printf ${en_quad}%.s {1..4})Blessings"
    copyright_notice "cython"          "$(printf ${en_quad}%.s {1..4})Cython"
    copyright_notice "cythongsl"       "$(printf ${en_quad}%.s {1..4})CythonGSL"
    copyright_notice "h5py"            "$(printf ${en_quad}%.s {1..4})H5Py"
    copyright_notice "matplotlib"      "$(printf ${en_quad}%.s {1..4})Matplotlib"
    copyright_notice "mpi4py"          "$(printf ${en_quad}%.s {1..4})MPI4Py"
    copyright_notice "nose"            "$(printf ${en_quad}%.s {1..4})Nose"
    copyright_notice "numpy"           "$(printf ${en_quad}%.s {1..4})NumPy"
    copyright_notice "parameterized"   "$(printf ${en_quad}%.s {1..4})parameterized"
    copyright_notice "pytest"          "$(printf ${en_quad}%.s {1..4})pytest"
    copyright_notice "scipy"           "$(printf ${en_quad}%.s {1..4})SciPy"
    printf "\nThese have been installed into separate directories in
\"${top_dir}\"
Any use of ${esc_concept} must conform to the license terms of the above
software in addition to its own. These can be found in the separate
installation directories.\n"
fi
# Notice about test errors
current_step="erroneous tests notice"
any_test_error_notices="no"
erroneous_test_notice(){
    # Arguments: Program name, [alternative message]
    progname="${1// /_}"
    progname="$(echo "${progname}" | tr '[:upper:]' '[:lower:]')"
    test_success="yes"
    eval "test_success=\"\${${progname}_test_success}\""
    if [ "${test_success}" == "no" ]; then
        if [ "${any_test_error_notices}" == "no" ]; then
            # First test error notice
            heading "Erroneous tests notice"
            any_test_error_notices="yes"
        else
            # Add newline between notices
            echo
        fi
        eval "test_log_path=\"\${${progname}_test_log}\""
        printf "${esc_bold}${esc_red}Warning: ${esc_normal}"
        real_name="${1/CONCEPT/$esc_concept}"
        if [ "${real_name}" == "MPI" ]; then
            if [ "${mpi}" == "mpich" ]; then
                real_name="MPICH"
            elif [ "${mpi}" == "openmpi" ]; then
                real_name="OpenMPI"
            fi
        fi
        printf "Some tests of ${real_name} did not pass successfully.\n"
        if [ -n "${2}" ]; then
            printf "${2}\n"
            if [ "${progname}" != "concept" ] && [ "${concept_test_success}" != "no" ]; then
                printf "As ${esc_concept} do seem to function correctly, "
                printf "you may choose to disregard this.\n"
            fi
        else
            printf "As ${real_name} did seem to install correctly, "
            printf "this is usually not of any concern.\n"
        fi
        printf "The logged output of the tests can be found in\n"
        printf "\"${test_log_path}\"\n"
    fi
}
erroneous_test_notice "CLASS"
erroneous_test_notice "FFTW"
erroneous_test_notice "FFTW for GADGET"
erroneous_test_notice "FreeType"
erroneous_test_notice "GADGET"
erroneous_test_notice "GSL"
erroneous_test_notice "HDF5"
erroneous_test_notice "libpng"
erroneous_test_notice "MPI"
erroneous_test_notice "ncurses"
erroneous_test_notice "NumPy"
erroneous_test_notice "OpenSSL"
erroneous_test_notice "Perl"
erroneous_test_notice "Python"
erroneous_test_notice "SciPy"
erroneous_test_notice "zlib"
erroneous_test_notice "CONCEPT" \
                      "${esc_italic}This should usually be taken seriously!${esc_no_italic}"
if [ "${any_test_error_notices}" == "yes" ]; then
    printf "The logged output of the entire installation process can be found in\n"
    printf "\"${log}\"\n"
fi

# Subprocess complete
printf "\n\n\n"
disable_status
if [ "${any_test_error_notices}" == "no" ]; then
    successfully_finish_status
fi
# Deactivate traps before exiting subprocess
trap : 0
) > "${log}" &
log_pid=$!
# End of subprocess #
#####################



################
# Display loop #
################
# Wait for the install log to be created
slept=0
while [ ! -f "${log}" ]; do
    sleep 1
    # After having slept for a long time, check that the job
    # has not just finished without producing a log file.
    ((slept += 1))
    if [ ${slept} == 30 ]; then
        error "Could not create the log file \"${log}\""
        exit 1
    fi
done

# Continuously print the tail of the install log
printf "\n\n"
tail -f "${log}" --pid ${log_pid} | while read line; do
    if [[ "${line}" == "${status_prefix}"* ]]; then
        status_backup_="${status}"
        status=${line:${status_prefix_length}}
        if [ "${status}" == "${status_disable}" ]; then
            # Disable status
            status_visible="${status_off}"
            status_backup="${status_backup_}"
            printf "${esc_up}${esc_erase}"
            printf "${esc_up}"
        elif [ "${status}" == "${status_enable}" ]; then
            # Enable status
            status_visible="${status_on}"
            status="${status_backup}"
            printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
        elif [ "${status}" == "${status_finish}" ]; then
            # Display loop complete. Do nothing
            :
        elif [ "${status_visible}" == "${status_on}" ]; then
            # Normal status update
            printf "${esc_up}${esc_erase}"
            printf "${esc_up}"
            printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
        fi
    else
        if [ "${status_visible}" == "${status_on}" ]; then
            # Line with status enabled
            printf "${esc_up}${esc_erase}"
            printf "${esc_up}"
            printf "%s\n" "${line}"
            printf "\n${esc_bold}${esc_reverted}${status}${esc_normal}\n"
        else
            # Line with status disabled
            printf "%s\n" "${line}"
        fi
    fi
done

# Remove the log file if no errors occurred
if [ "${fast_install}" == "no" ] && \
    [ "$(tail -n 1 "${log}")" == "${status_prefix}${status_finish_successfully}" ]; then
    rm -f "${log}"
fi

# Installation complete. Deactivate traps before exiting.
if [ "${say_goodbye}" != "no" ]; then
    printf "${esc_bold}${esc_green}${esc_concept} installation finished${esc_normal}\n"
fi
trap : 0
